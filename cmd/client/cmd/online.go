/*
Copyright © 2021 NAME HERE <EMAIL ADDRESS>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
    "context"
    "fmt"
    "io"
    "io/ioutil"
    "os"
    "path/filepath"

    "github.com/configcenter/pkg/pb"
    "github.com/configcenter/pkg/template"
    "github.com/spf13/cobra"
    "google.golang.org/grpc"
)

// onlineCmd represents the online command
var onlineCmd = &cobra.Command{
    Use:   "online",
    Short: "Generate online",
    Long: `Generate configfile partly or totoally online. 
With assigned Arg "--pathin/-i", configfile will be generated by local template and remote serviceInfo
Without Arg "--pathin/-i", configfile will be generated by remote`,
    Example: `$ ./cfgtool create online --version 1.0.0 --env 00 --cluster EzEI.set0 --globalid 141 --localid 3 --pathin /etc/configcenter/template00 --pathout /etc/configcenter
$ ./cfgtool create online -v 1.0.0 -e 00 -c EzEI.set0 -g 141 -l 3 -o /etc/configcenter`,
    Run: CreatePartlyOnline,
}

func init() {
    createCmd.AddCommand(onlineCmd)
    onlineCmd.Flags().StringVarP(&object.PathIn, "pathin", "i", "", "assign input path of local template")
    onlineCmd.Flags().StringVarP(&object.TemplateName, "templateName", "t", "", "assign template on remote")
}

func CreatePartlyOnline(cmd *cobra.Command, args []string) {
    //根据生成模式构建文件、选择target关键字
    var binaryFile []byte
    var fileName, target string
    //指定本地模板
    if object.PathIn != "" {
        //指定本地模板，且指定服务端模板名，返回错误
        if object.TemplateName != "" {
            fmt.Println("Repeated template assigned in Pathin and remote")
            return
        }
        file, err := os.Open(object.PathIn)
        if err != nil {
            fmt.Println(fmt.Sprintf("open file at %s err", object.PathIn))
            panic(err)
        }
        binaryFile, err = ioutil.ReadAll(file)
        if err != nil {
            fmt.Println(fmt.Sprintf("read file at %s err", object.PathIn))
            panic(err)
        }
        fileName = filepath.Base(object.PathIn)
        target = template.PartlyOnline
    } else {
        //未指定本地模板，且未指定服务端模板名，返回错误
        if object.TemplateName == "" {
            fmt.Println("Please select input template or assign remote template name")
            return
        }
        target = template.NodeConfig
    }
    //构建请求结构体
    configReq := pb.CfgReq{
        UserName: object.UserName,
        Target:   []string{target},
        File: &pb.CompressedFile{
            FileName: fileName,
            FileData: binaryFile,
        },
        CfgVersions: []*pb.CfgVersion{
            {
                Version: object.Version,
                Envs: []*pb.Environment{
                    {
                        Num: object.Env,
                        Clusters: []*pb.Cluster{
                            {
                                ClusterName: object.Cluster,
                                Nodes: []*pb.Node{
                                    {
                                        GlobalId: object.GlobalId,
                                        LocalId:  object.LocalId,
                                        Template: object.TemplateName, //可传空
                                    },
                                },
                            },
                        },
                    },
                },
            },
        },
    }
    //读取grpc配置信息
    err := GetGrpcClient()
    if err != nil {
        panic(err)
    }
    //新建grpc客户端
    conn, err := grpc.Dial(GrpcInfo.Socket, grpc.WithInsecure())
    if err != nil {
        fmt.Println(err)
        return
    }
    defer conn.Close()
    client := pb.NewConfigCenterClient(conn)
    resp, err := client.GET(context.Background(), &configReq)
    if err != nil {
        fmt.Println(err)
        return
    }
    if resp.Status != "ok" {
        fmt.Println(resp.Status)
        return
    }
    dirPath := filepath.Dir(object.PathIn)
    if object.PathOut != "" {
        dirPath = object.PathOut
    }
    err = os.MkdirAll(dirPath, os.ModePerm)
    if err != nil {
        fmt.Println(err)
        return
    }
    f, err := os.OpenFile(dirPath+"/"+resp.File.FileName, os.O_RDWR|os.O_CREATE|os.O_TRUNC, os.ModePerm)
    defer f.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
    n, err := f.Write(resp.File.FileData)
    if err == nil && n < len(resp.File.FileData) {
        err = io.ErrShortWrite
        fmt.Println(err)
        return
    }
}
