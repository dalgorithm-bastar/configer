<center><font size=7>TD107 新核心交易系统架构总体设计文档（配置中心卷）v4.0</font></center>

- [1. 概述](#1-概述)
- [2. 名词解释](#2-名词解释)
- [3. 参考文档](#3-参考文档)
- [4. 设计约束与已知限制](#4-设计约束与已知限制)
- [5. 整体视图](#5-整体视图)
  - [5.1 外部视图](#51-外部视图)
  - [5.2 内部视图](#52-内部视图)
    - [5.2.1 逻辑视图](#521-逻辑视图)
      - [5.2.1.1 模块关系图](#5211-模块关系图)
      - [5.2.1.2 接口模块pb](#5212-接口模块pb)
      - [5.2.1.3 服务模块service](#5213-服务模块service)
      - [5.2.1.4 生成模块generate](#5214-生成模块generate)
      - [5.2.1.5 日志模块log](#5215-日志模块log)
      - [5.2.1.6 辅助模块util](#5216-辅助模块util)
      - [5.2.1.7 存储模块](#5217-存储模块)
- [6. 数据结构](#6-数据结构)
  - [6.1 配置数据层级划分](#61-配置数据层级划分)
  - [6.2 rpc接口数据模型](#62-rpc接口数据模型)
    - [6.2.1 CfgReq](#621-cfgreq)
      - [6.2.1.1 CfgReq](#6211-cfgreq)
      - [6.2.1.2 AnyFile](#6212-anyfile)
      - [6.2.1.3 Target字段和接口、功能实现的对照表](#6213-target字段和接口功能实现的对照表)
      - [6.2.1.4 Action字段和接口、功能实现的对照表](#6214-action字段和接口功能实现的对照表)
      - [6.2.1.5 Type字段和接口、功能实现的对照表](#6215-type字段和接口功能实现的对照表)
      - [6.2.1.6 ArgRange字段](#6216-argrange字段)
    - [6.2.2 CfgResp](#622-cfgresp)
    - [6.2.3 修改动作缓存表ChangeList](#623-修改动作缓存表changelist)
  - [6.3 存储结构](#63-存储结构)
  - [6.4 输入配置文件包中的数据模型规范](#64-输入配置文件包中的数据模型规范)
- [7. 技术设计](#7-技术设计)
  - [7.1 生成配置文件流程图](#71-生成配置文件流程图)
  - [7.2 对生成第三方文件的支持](#72-对生成第三方文件的支持)
- [8. 接口设计](#8-接口设计)
  - [8.1 GET](#81-get)
    - [8.1.1 获取生成后的配置文件数据包](#811-获取生成后的配置文件数据包)
    - [8.1.2 获取节点原始数据](#812-获取节点原始数据)
    - [8.1.3 获取基础设施信息文件](#813-获取基础设施信息文件)
    - [8.1.4 获取所有版本号](#814-获取所有版本号)
  - [8.2 PUT](#82-put)
    - [8.2.1 缓存对部署信息的修改](#821-缓存对部署信息的修改)
    - [8.2.2 缓存对配置数据的修改](#822-缓存对配置数据的修改)
  - [8.3 COMMIT](#83-commit)
    - [8.3.1 提交缓存的配置数据](#831-提交缓存的配置数据)
    - [8.3.2 提交基础设施信息](#832-提交基础设施信息)
  - [8.4 DELETE](#84-delete)
  - [8.5 GetLatestConfigByEnvNum](#85-getlatestconfigbyenvnum)
- [9. 操控设计](#9-操控设计)
- [10. 监测设计](#10-监测设计)
- [附录](#附录)
  - [直接引用的包列表](#直接引用的包列表)

# 1. 概述

配置中心对交易系统的配置数据实行集中化、版本化的管理，各个集群需要向配置中心提供自身的部署信息文件、服务声明文件和配置模板，再由配置中心解析、校验并生成最终可用的组播信息文件和配置文件。

在使用配置中心生成配置文件之前，用户需要上传一份基础设施信息文件。该文件记录诸如主机信息、网络信息等内容。配置中心将根据基础设施文件，自动扩展各集群的部署信息文件。

# 2. 名词解释

|    名词    |    释义    |        特殊说明        |
| :--------: | :-------------------: | :----------------: |
| 配置数据 | 与配置相关的数据，包括配置模板、服务清单、工作流程文件、公共信息文件、配置文件中的一项或多项 |        |
| 配置模板 | 包含固定配置信息以及可替换信息的文件 |  |
| 配置模板组 | 以应用集群为单位的一组配置模板 ||
| 配置文件 | 使用模板生成后的可用的配置文件 |  文件数量根据语境确定  |
| 服务声明文件 | 以集群为单位，包含该集群下所有服务的名称和内容的单个文件 |  |
| 工作流程文件 | 以集群为单位，包含操控中心启动该集群的流程信息 ||
| 服务信息 | 服务声明文件上的信息 |  |
| 基础设施信息文件 | 基础设施信息，如主机、网络信息 | |
| 前端 | 指配置中心前端，包含网页版和命令行工具 |           |
| 用户名 | 前端进行操作的用户的名称 |    |
| 自动化系统 | 需要从配置中心拉取配置的自动运行的系统，如操控中心 | |

# 3. 参考文档

# 4. 设计约束与已知限制

由于当前交易系统使用的配置文件格式多样、结构各异，因此配置中心不对具体的配置进行key-value存储，即配置中心不解析各个集群的配置模板。但配置中心提供基于gotemplate的文本替换，用户可使用预设参数，将实际值填充到模板的自定义位置。

# 5. 整体视图

## 5.1 外部视图

配置中心由前端(包含命令行与网页端)、服务端和存储端组成。其中网页端借助envoy实现http与grpc之间的代理转发。其结构图如下：

![alt](../../images/概设/交互方4.0.svg)

## 5.2 内部视图

### 5.2.1 逻辑视图

按照逻辑功能的不同，可将配置中心分为接口模块(package pb)、服务模块(package service),生成模块(package generate),辅助模块(package util),日志模块(package log)，定义模块(package define)和存储模块(package repository，package datasource)

#### 5.2.1.1 模块关系图

![alt](../../images/概设/包图.svg)

#### 5.2.1.2 接口模块pb

配置中心服务端使用grpc实现一组接口，完成对外交互的需求。接口包含GET、PUT、POST和DELETE，接口行为与语义一致。配置中心的所有接口使用统一的请求结构体CfgReq和返回结构体CfgResp。

服务端接口由管理模块的Manager类实现，类图如下：

![alt](../../images/概设/处理模块.svg)

#### 5.2.1.3 服务模块service

管理模块负责直接处理接口模块接收的外部请求，并实现处理逻辑。管理模块不负责功能的具体实现，如储存和读取、模板的生成等，这些功能通过调用其他模块的接口实现。在处理完成后，管理模块负责将处理结果和请求结果返回接口模块。

#### 5.2.1.4 生成模块generate

该模块实现配置文件的生成。其输入为精确到配置方案的配置文件包、基础设施信息文件、ip范围、端口范围、环境号。其处理流程可参阅7.1节生成流程图。

#### 5.2.1.5 日志模块log

该模块负责管理可供其他模块调用的结构化日志对象和格式化日志对象。其类图如下：

![alt](../../images/概设/日志模块.svg)

#### 5.2.1.6 辅助模块util

该模块负责实现一组工具函数，实现文件的压缩和解压、字符串操作等辅助功能。包内包含两个源文件fileUtil.go和stringUtil.go，分别实现针对文件和字符串的相关功能。该包内还包含一个streamfile.go文件，实现了一个虚拟文件类型，用于流式文件的压缩解压，无实际用途。

#### 5.2.1.7 存储模块

存储模块分为repository接口层和datasource实现层。接口名称为Storage，其中定义了数据操作接口，datasource中分别定义了针对etcd和本地压缩包的实现类EtcdType和CompressedFileType，整个模块的类图如下：

![alt](../../images/概设/存储模块.svg)

# 6. 数据结构

## 6.1 配置数据层级划分

下图给出了配置中心数据的层级关系：

![alt](../../images/概设/信息层级v3.1.svg)

一个用于示例的配置文件数据包树状结构为：

```shell
.
├── 3.1.0
│   ├── scheme1
│   │   ├── DTP
│   │   │   ├── CS
│   │   │   │   ├── deployment
│   │   │   │   │   ├── set1
│   │   │   │   │   │   └── deployment.yaml
│   │   │   │   │   └── set2
│   │   │   │   │       └── deployment.yaml
│   │   │   │   ├── service
│   │   │   │   │   ├── engine1
│   │   │   │   │   │   └── service.yaml
│   │   │   │   │   └── service.yaml
│   │   │   │   └── template
│   │   │   │       ├── app_shl.toml
│   │   │   │       ├── nilfile.toml
│   │   │   │       └── so1
│   │   │   │           └── so1.toml
│   │   │   └── MC
│   │   │       ├── deployment
│   │   │       │   ├── set1
│   │   │       │   │   └── deployment.yaml
│   │   │       │   └── set2
│   │   │       │       └── deployment.yaml
│   │   │       ├── service
│   │   │       │   └── service.yaml
│   │   │       └── template
│   │   │           └── app_shl.toml
│   │   └── MTP
│   │       └── RC
│   │           ├── deployment
│   │           │   ├── set1
│   │           │   │   └── deployment.yaml
│   │           │   └── set2
│   │           │       └── deployment.yaml
│   │           ├── service
│   │           │   └── service.yaml
│   │           └── template
│   │               └── app_shl.toml
│   └── scheme2
└── infrastructure.yaml
```

## 6.2 rpc接口数据模型

### 6.2.1 CfgReq

所有rpc请求的请求结构体均使用CfgReq，其内部结构之间的关系已在1.2.1节中给出，下面给出各个字段的含义

#### 6.2.1.1 CfgReq

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| UserName |    string     | 当前操作者的用户名 |
|  Target   | string[] |   指令字符串，用于区分要获取的目标的类型   |
| Action | string | 指令字符串，用于描述修改动作 |
| EnvNum | string | 环境号 |
| File | AnyFile | 用于存放要提交的文件 |
| Version | string | 目标版本号 |
| Scheme | string | 目标配置方案 |
| Type | string | 目标信息类型 |
| Platform | string | 目标平台 |
| NodeType | string | 目标节点类型 |
| Set | string | 目标集群 |
| ArgRange | ArgRange | 输入ip、port范围 |

#### 6.2.1.2 AnyFile

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| FileName |    string     | 文件名 |
|  Content   | byte[] |   文件内容   |

#### 6.2.1.3 Target字段和接口、功能实现的对照表

Target字段主要用于确定要获取的资源种类，其类型为字符串，具备良好的可扩展性。

下表列出了各个功能点中Target关键字应当如何设置：

|     实现功能    |      接口      |      Target    | 说明 |
| :------------: | :-----------: | :-------------: | :-------------: |
| 获取生成的所有配置文件 |      GET       | "config" |  |
| 获取基础设施信息文件 |      GET       | "infra" |  |
| 获取所有版本号 |      GET       | "version" |   |
| 获取原始数据 |      GET       | "raw" |   |
| 获取用户缓存的数据 | GET | "cache" |  |
|  缓存配置数据   |      PUT       |  "raw"  | 目标版本号放在Version字段 |
|  提交基础设施信息文件   |      COMMIT       |  "infra"  |  |
|  提交用户缓存的数据   |      COMMIT       |  "raw"  |  |

#### 6.2.1.4 Action字段和接口、功能实现的对照表

Action字段主要用于限定更新范围，其类型为字符串。

下表列出了各个功能点中Action关键字应当如何设置：

|     实现功能    |      接口      |      Action     | 说明 |
| :------------: | :-----------: | :-------------: | :-------------: |
|  缓存配置数据   |      PUT       |  "ResetAtRoot"  |  在版本范围内全量更新，必须上传符合格式要求的配置数据包，必须配合其他请求参数  |
|  缓存配置数据   |      PUT       |  "ResetAtLeaf"  |  在其他参数限定的范围内全量更新  |
|  缓存配置数据   |      PUT       |  "AddAndReplaceAtLeaf"  |  在其他参数限定的范围内增量更新(允许文件重名，重名即覆盖原文件)  |
| 缓存配置数据 | PUT | "AddButNoReplaceAtLeaf" | 在其他参数限定的范围内增量更新(重名时不覆盖原文件) |

#### 6.2.1.5 Type字段和接口、功能实现的对照表

Type字段用于指定树状结构中的一层，但具有特殊限制，其用法如下：

|     实现功能    |      接口      |      Type     | 说明 |
| :------------: | :-----------: | :-------------: | :-------------: |
|  提交配置数据   |      PUT       |  "deployment"  | 更新部署信息 |
|  提交配置数据   |      PUT       |  "service"  |  更新服务信息  |
|  提交配置数据   |      PUT       |  "template"  |  更新配置模板  |
| 获取原始数据 |      GET       | "deployment" | 获取部署信息 |
| 获取原始数据 |      GET       | "service" | 获取服务信息 |
| 获取原始数据 |      GET       | "template" | 获取配置模板 |

#### 6.2.1.6 ArgRange字段

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| TopicIp | []string  | 用于生成组播地址的Ip范围 |
| TopicPort | []string |  用于生成组播地址的端口范围  |

### 6.2.2 CfgResp

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| status | string | "ok"或执行过程中的错误日志 |
| VersionList | VersionInfo[] | 版本号数组 |
| File | AnyFile | 文件数据 |

其中Version类型结构如下：

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| Name | string | 标准三段式版本号 |
| User | string | 提交该版本号的用户 |
| Time | timestamp | 提交时间的13位时间戳 |

### 6.2.3 修改动作缓存表ChangeList

按照时间顺序缓存用户的修改行为、记录每次行为需要修改的文件，在某些情况下也可以没有文件。在有文件的情况下，文件保存在etcd中。该表结构如下：

```json
{
  "changeList":[
    {
      "stepOrder":1,
      "action":"ResetAtLeaf",
      "level":"scheme1/template/DTP",
      "keysToFile":["Path1","Path2"]
    },
    {
      "stepOrder":2,
      "action":"AddAndReplaceAtLeaf",
      "level":"scheme1/template/DTP/MC",
      "keysToFile":["Path3","Path4"]
    }
  ]
}
```

Path的规则见存储结构。

## 6.3 存储结构

etcd中的键值对如下表所示，其中&前缀表示取该变量的实际值，[]后缀代表该变量的一系列值的集合组成的逗号分隔字符串： 
| key | value | 说明 |
|:-----------------:|:------------------:|:-------------:|
| VersionList | string[] | 代表所有版本的序列，该序列有序 |
| &Version/SchemeList | string[] |代表某版本下配置方案的序列 |
| infrastructure | byte[] | 基础设施信息文件 |
| &Version/&Scheme/&Platform/&NodeType/&Type/&Set/&FileName |byte[] |某个set下的某份文件 |
| &Version/&Scheme/&Platform/&NodeType/&Type/&FileName | byte[] | 某节点类型下的某份文件|
|&UserName/&StepOrder/&Scheme/&Platform/&NodeType/&Type/&Set/&FileName | byte[] | 用户缓存的某个set下的某份文件 |
|&UserName/&StepOrder/&Scheme/&Platform/&NodeType/&Type/&FileName | byte[] |用户缓存的某节点类型下的某份文件|
|&Version/Perm.yaml|byte[]|该版本|

## 6.4 输入配置文件包中的数据模型规范

参阅MAL107新核心交易系统架构用户手册（配置中心卷）

# 7. 技术设计

## 7.1 生成配置文件流程图

![alt](../../images/概设/整体流程图.svg)

## 7.2 对生成第三方文件的支持

配置中心可针对第三方要求的配置文件样式进行生成。生成原则是，第三方文件的生成与配置中心自有生成方案分离，即第三方文件使用配置文件包、基础设施信息文件以及配置中心自有文件生成结果进行生成，不得侵入配置中心自有生成流程。

# 8. 接口设计

为方便描述，本节中使用json结构体表示请求结构体进行演示

## 8.1 GET

GET接口可用于从服务端获取信息，包括原始数据（含配置模板、服务信息、部署信息、基础设施信息）和生成后的配置数据包。

### 8.1.1 获取生成后的配置文件数据包

配置文件由配置中心动态生成，因此每次获取配置都是获取生成后的全量的配置文件，其动态分配部分会存在一定差异。返回的文件包含生成的部署信息、生成的配置文件、生成的topicInfo总表。

以下为请求体示例：

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"config",
    "EnvNum":"00",
    "Version":"1.0.0",
    "Scheme":"scheme1",
    "ArgRange":{
      "TopicIp":["10.112.3.5","10.112.5.5"],
      "TopicPort":["1024","2376"]
    }
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[],  //返回文件对象时此项为空
  "File": {
    "FileName":"name1", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

返回结构体中FileData的结构为：

```json
.
└── 3.1.0_scheme1
    ├── huarui_files
    │   ├── host.cfg
    │   ├── node.cfg
    │   └── route.cfg
    └── origin_res
        ├── DTP
        │   ├── CS
        │   │   ├── set1
        │   │   │   ├── deployment.yaml
        │   │   │   ├── host1_1
        │   │   │   │   ├── app_shl.toml
        │   │   │   │   ├── nilfile.toml
        │   │   │   │   └── so1
        │   │   │   │       └── so1.toml
        │   │   │   └── topicInfo.json
        │   │   └── set2
        │   │       ├── deployment.yaml
        │   │       ├── host2_2
        │   │       │   ├── app_shl.toml
        │   │       │   ├── nilfile.toml
        │   │       │   └── so1
        │   │       │       └── so1.toml
        │   │       └── topicInfo.json
        │   └── MC
        │       ├── set1
        │       │   ├── deployment.yaml
        │       │   ├── host1_3
        │       │   │   └── app_shl.toml
        │       │   ├── host2_4
        │       │   │   └── app_shl.toml
        │       │   └── topicInfo.json
        │       └── set2
        │           ├── deployment.yaml
        │           ├── host3_5
        │           │   └── app_shl.toml
        │           ├── host4_6
        │           │   └── app_shl.toml
        │           └── topicInfo.json
        ├── MTP
        │   └── RC
        │       ├── set1
        │       │   ├── deployment.yaml
        │       │   ├── host1_7
        │       │   │   └── app_shl.toml
        │       │   ├── host2_8
        │       │   │   └── app_shl.toml
        │       │   └── topicInfo.json
        │       └── set2
        │           ├── deployment.yaml
        │           ├── host3_9
        │           │   └── app_shl.toml
        │           ├── host4_10
        │           │   └── app_shl.toml
        │           └── topicInfo.json
        ├── deployList.json
        └── topicList.json
```

### 8.1.2 获取节点原始数据

以下请求体表示请求获取版本号1.0.0，配置方案scheme1，平台DTP，节点类型RC，类型template的所有配置文件模板。

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"raw",
    "Version":"1.0.0",
    "Scheme":"scheme1",
    "Platform":"DTP",
    "NodeType":"RC",
    "Type":"template"
  }
}
```

假设返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[],  //返回文件时此项为空
  "File": {
    "FileName":"DTP.RC.templates.tar.gz", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

要获取部署信息文件和服务信息文件，只需修改Type字段为相应的关键字即可。

返回结构体中FileData的结构为：

```json
template
├── app_shl.toml
├── biz_engine
│   ├── matcher_so
│   │   └── matcher_config.toml
│   └── riskcontrol_so
│       └── risk_control_config.toml
└── component
    ├── data_engine.toml
    ├── event_framework.toml
    └── logger.toml
```

### 8.1.3 获取基础设施信息文件

使用Target字段指明要导出的是"infra"。示例如下：

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"infra"
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[],  //返回文件时此项为空
  "File": {
    "FileName":"infrastructure.yaml", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

### 8.1.4 获取所有版本号

使用Target字段指明要导出的是"version"。例如:

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"version",
  }
}
```

假设当前共有两个版本，v0.0.1和v0.0.2，则返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "VersionList":[
    {
      "name":"0.0.1",
      "user":"chfgu",
      "time":"xxxxxx"
    },
    {
      "name":"0.0.2",
      "user":"xwang3",
      "time":"xxxxxx"
    }
  ],
  //返回版本数据时该项为空
  "File": {
    "FileName":"", 
    "FileData":
  }
}
```

## 8.2 PUT

PUT接口用于缓存用户单次提交的修改，用户在请求体中用参数限定修改动作的范围，并在上传的配置数据包中提交相应的文件。下面分别就针对部署信息和针对其他配置数据的缓存举例。

### 8.2.1 缓存对部署信息的修改

用户someBody想要重置（reset）DTP.RC.set1层级的部署信息，则应构建请求体如下：

```json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"raw",
    "Action":"ResetAtLeaf",
    "Scheme":"scheme1", //指定配置方案，默认更新在最新版本的配置数据上
    "Platform":"DTP",
    "NodeType":"RC",
    "Type":"template",
    "Set":"set1",
    "File":{
      "FileName":"deployment.yaml",
      "Content":"content"
    }
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok"
}
```

此处示例为更新单个set，实际情况下可以在节点类型或更高层级进行更新。若在更高层级更新，需构建与配置中心数据包结构一致的上传文件数据包。

### 8.2.2 缓存对配置数据的修改

用户someBody想要更新（AddAndReplaceAtLeaf）DTP.RC层级的**某些**配置模板，则应构建请求体如下：

```json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"raw",
    "Action":"ResetAtLeaf",
    "Scheme":"scheme1", //指定配置方案，默认更新在最新版本的配置数据上
    "Platform":"DTP",
    "NodeType":"RC",
    "Type":"template",
    "File":{
      "FileName":"app_shl.toml",
      "Content":"content"
    }
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok"
}
```

在用户提交后，配置中心的配置数据包中RC.template下的app_shl.json文件将被替换。

## 8.3 COMMIT

### 8.3.1 提交缓存的配置数据

COMMIT接口用于提交版本，请求体内的Target关键字设为raw。例如，下列请求体表示请求配置中心提交用户someBody请求上传的配置。

``` json
{
  "CfgReq":{
    "CfgReq":{
      "UserName":"someBody",
      "Target":"raw"
    }
  }
}
```

假设本次提交创建的版本号为0.0.3，则返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "VersionList":[
    {
      "Version":"0.0.3",
      "User":"someBody",
      "Time":"xxxxxxx"
    }
  ],
  "File": {
      "FileName":"", 
      "FileData":
  }
}
```

用户也可在version字段中指定本次提交的版本号。配置中心在检测到版本号不冲突后将以该版本号提交，否则返回一个错误提示

### 8.3.2 提交基础设施信息

COMMIT接口用于提交基础设施信息，请求体内的Target关键字设为infra。例如，下列请求体表示请求配置中心提交用户someBody请求上传的infrastructure.json。

``` json
{
  "CfgReq":{
    "CfgReq":{
    "UserName":"someBody",
    "Target":"infra",
    "File":{
        "FileName":"infrastructure.yaml",
        "Content":"content"
      }
    }
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok"
}
```

## 8.4 DELETE

delete接口负责删除用户目录下缓存的修改信息。构建请求体如下：

```json
{
  "CfgReq":{
    "UserName":"someBody"
  }
}
```

## 8.5 GetLatestConfigByEnvNum

GetLatestConfigByEnvNum接口负责根据传入的环境号获取该环境号下的最新配置

接口原型：

```go
//获取某一环境号下最新生成的配置文件
//输入为环境号
//输出为配置文件压缩包，压缩格式为.tar.gz，或可能的错误
func GetLatestConfigByEnvNum(envNum string)(configFile AnyFile,error err){}

//AnyFile结构体，用于文件传输
type AnyFile struct {
    FileName             string
    FileData             []byte
}
```

构建请求体如下：

```json
{
  "envNum": "01"
}
```

返回结构体如下：

```json
{
  "AnyFile":{
    "FileName":"config.tar.gz",
    "FileData":data
  }
}
```

# 9. 操控设计

参阅MAL107 新核心交易系统架构用户手册（配置中心卷）第三章 使用配置中心

# 10. 监测设计

暂无

# 附录

## 直接引用的包列表

|包名称|用途|
|:------------:|:-------------:|
|github.com/agiledragon/gomonkey/v2|单测时用于函数打桩|
|github.com/coreos/etcd|运行时用于操作etcd接口|
|github.com/golang/mock|单测时用于模拟接口行为|
|github.com/golang/protobuf|运行时用于grpc编解码|
|github.com/lestrrat/go-file-rotatelogs|运行时用于日志文件切分|
|github.com/mholt/archiver|运行时用于流式文件的压缩和解压|
|github.com/spf13/cobra|运行时用于解析命令行命令|
|github.com/spf13/viper|运行时用于解析配置文件和校验输入项|
|go.uber.org/zap|运行时用于打印日志|
|golang.org/x/net|运行时用于grpc编解码|
|google.golang.org/grpc|运行时用于实现rpc服务|
|gopkg.in/yaml.v3|运行时用于yaml文件编解码|
|xchg.ai/sse/gracefully|运行时用于多个goroutine的优雅退出|
