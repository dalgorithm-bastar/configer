- [1. 总体设计](#1-总体设计)
  - [1.1 整体视图](#11-整体视图)
  - [1.2 服务端逻辑划分](#12-服务端逻辑划分)
    - [1.2.1 模块关系图](#121-模块关系图)
    - [1.2.2 接口模块](#122-接口模块)
    - [1.2.3 处理模块](#123-处理模块)
      - [1.2.3.1 管理模块manage](#1231-管理模块manage)
      - [1.2.3.2 生成模块template](#1232-生成模块template)
      - [1.2.3.3 日志模块log](#1233-日志模块log)
      - [1.2.3.4 辅助模块util](#1234-辅助模块util)
    - [1.2.4 存储模块](#124-存储模块)
  - [1.4 设计约束](#14-设计约束)
- [2 数据模型](#2-数据模型)
  - [2.1 配置数据层级划分](#21-配置数据层级划分)
  - [2.2 rpc接口数据模型](#22-rpc接口数据模型)
    - [2.2.1 CfgReq](#221-cfgreq)
      - [2.2.1.1 CfgReq](#2211-cfgreq)
      - [2.2.1.2 CfgVersion](#2212-cfgversion)
      - [2.2.1.3 Environment](#2213-environment)
      - [2.2.1.4 Cluster](#2214-cluster)
      - [2.2.1.5 Node](#2215-node)
      - [2.2.1.6 Target字段和接口、功能实现的对照表](#2216-target字段和接口功能实现的对照表)
    - [2.2.2 CfgResp](#222-cfgresp)
  - [2.3 存储结构](#23-存储结构)
- [3 工作顺序图](#3-工作顺序图)
  - [3.1 配置获取](#31-配置获取)
    - [3.1.1 层级获取](#311-层级获取)
    - [3.1.2 文件获取](#312-文件获取)
  - [3.2 配置缓存](#32-配置缓存)
  - [3.3 删除缓存配置](#33-删除缓存配置)
  - [3.4 版本提交](#34-版本提交)
  - [3.5 导入配置](#35-导入配置)
  - [3.6 导出配置](#36-导出配置)
- [4 rpc接口示例](#4-rpc接口示例)
  - [4.1 GET](#41-get)
    - [4.1.1 获取节点配置文件](#411-获取节点配置文件)
    - [4.1.2 获取集群模板组](#412-获取集群模板组)
    - [4.1.3 获取集群工作流程文件组](#413-获取集群工作流程文件组)
    - [4.1.4 获取公共信息文件](#414-获取公共信息文件)
    - [4.1.5 获取所有版本号](#415-获取所有版本号)
    - [4.1.6 获取所有环境号](#416-获取所有环境号)
    - [4.1.7 获取所有集群名称](#417-获取所有集群名称)
    - [4.1.8 基于网页前端的go template单条信息查询](#418-基于网页前端的go-template单条信息查询)
    - [4.1.9 获取集群部署信息](#419-获取集群部署信息)
  - [4.2 PUT](#42-put)
  - [4.3 DELETE](#43-delete)
  - [4.4 POST](#44-post)
- [5.命令行工具](#5命令行工具)
  - [5.1 客户端cfgtool及相关命令](#51-客户端cfgtool及相关命令)
    - [5.1.1 create online](#511-create-online)
    - [5.1.2 create offline](#512-create-offline)
    - [5.1.3 get](#513-get)
    - [5.1.4 find](#514-find)
    - [5.1.5 delete](#515-delete)
    - [5.1.6 put](#516-put)
    - [5.1.7 post](#517-post)
  - [5.2 服务端cfgsrv及相关命令](#52-服务端cfgsrv及相关命令)
    - [5.2.1 modify](#521-modify)
    - [5.2.2 clearall](#522-clearall)
- [6.项目测试](#6项目测试)
  - [6.1 单元测试](#61-单元测试)
  - [6.2 性能测试](#62-性能测试)
  - [6.3 模糊测试](#63-模糊测试)
- [7.部署设计](#7部署设计)
- [8.容灾设计](#8容灾设计)
- [补充说明](#补充说明)
  - [词汇表](#词汇表)
  - [配置中心升级](#配置中心升级)
  - [关于导入的配置数据的要求](#关于导入的配置数据的要求)
  - [模板函数](#模板函数)
    - [GetInfo(implicitIndex bool, clusterName string, serviceName string)(string,error)](#getinfoimplicitindex-bool-clustername-string-servicename-stringstringerror)
    - [CtlFind(target, version, env, cluster, service string)(string, error)](#ctlfindtarget-version-env-cluster-service-stringstring-error)
    - [UnsafeGetInfo(implicitIndex bool, version, env, cluster, service string)(string, error)](#unsafegetinfoimplicitindex-bool-version-env-cluster-service-stringstring-error)

# 1. 总体设计

配置中心对交易系统的各个集群的配置信息实行集中的、版本化的管理，各个集群需要向配置中心提供自身的服务清单和配置模板，配置中心解析各集群的服务清单，校验模板上要求替换的服务信息是否存在，并根据模板生成各个节点的配置文件。

上传配置数据时，应当以版本为单位附带一份公共信息文件。该文件记录较为基础和底层的信息，如物理机信息等。服务清单上，服务名称对应的值可以使用公共信息的名称，配置中心在填充模板时将自动替换为公共信息文件上对应的值

## 1.1 整体视图

配置中心由前端(包含命令行与网页端)、服务端和存储端组成。其中网页端借助envoy实现http与grpc之间的代理转发。其结构图如下：

![alt](svg/总体架构.svg)

在交易系统启动前，配置中心与操控中心进行交互，无需人工干预，其工作流程大致如下：

![alt](svg/操控中心交互.svg)

配置数据的版本更新等操作在配置中心网页前端完成，命令行工具仅在调试和紧急情况下使用

## 1.2 服务端逻辑划分

按照逻辑功能的不同，可将配置中心分为接口模块(package pb)、处理模块(package manage,package template,package util,package log)和存储模块(package storage)

### 1.2.1 模块关系图

![alt](svg/包图.svg)

### 1.2.2 接口模块

配置中心服务端使用grpc实现一组接口，完成对外交互的需求。接口包含GET、PUT、POST和DELETE，接口行为与语义一致。配置中心的所有接口使用统一的请求结构体CfgReq和返回结构体CfgResp。

服务端接口由管理模块的Manager类实现，类图如下：

![alt](svg/处理模块.svg)

请求结构体CfgReq如下图所示：

![alt](svg/请求结构体.svg)

返回结构体CfgResp如下图所示：

![alt](svg/返回结构体.svg)

### 1.2.3 处理模块

处理模块包含管理模块manage、生成模块template、日志模块log、辅助模块util

#### 1.2.3.1 管理模块manage

管理模块负责直接处理接口模块接收的外部请求，并实现处理逻辑。管理模块不负责功能的具体实现，如储存和读取、模板的生成等，这些功能通过调用其他模块的接口实现。在处理完成后，管理模块负责将处理结果和请求结果返回接口模块。

#### 1.2.3.2 生成模块template

负责实现模板的填充。该模块维护一个模板对象，并根据需要把配置模板注册到模板对象中。填充模板时，通过模块内的一组预设的函数来实现，预设函数的详情在说明部分给出。该模块类图如下：

![alt](svg/生成模块.svg)

#### 1.2.3.3 日志模块log

该模块负责管理可供其他模块调用的结构化日志对象和格式化日志对象。其类图如下：

![alt](svg/日志模块.svg)

#### 1.2.3.4 辅助模块util

该模块负责实现一组工具函数，实现文件的压缩和解压、字符串操作等辅助功能。包内包含两个源文件fileUtil.go和stringUtil.go，分别实现针对文件和字符串的相关功能。

### 1.2.4 存储模块

存储模块分为repository接口层和datasource实现层。接口名称为Storage，其中定义了数据操作接口，datasource中分别定义了针对etcd和本地压缩包的实现类EtcdType和CompressedFileType，整个模块的类图如下：

![alt](svg/存储模块.svg)

## 1.4 设计约束

由于当前交易系统使用的配置文件格式多样、结构各异，因此配置中心不对具体的配置进行key-value存储，即配置中心不解析各个集群的配置模板。但配置中心提供基于go template的查询函数，用户可对单条信息进行查询

配置中心采用模板生成的方式，在当前实际限制下实现服务管理和配置文件生成。

# 2 数据模型

## 2.1 配置数据层级划分

下图给出了配置中心数据的层级关系：

![alt](svg/信息层级.svg)

在设计过程中，最终的节点配置文件由配置模板上的固定项和可替换项组成，而部署信息被认为是对集群内部的服务，保存在服务清单上，在生成配置文件时按照该节点的全局节点号和集群内编号获取。

为了加强配置中心的服务管理能力，减轻开发和运维人员的负担，我们将一些公共信息单独提取成文件，在版本层面进行管理。在需要获取这些文件时，在服务清单上给出公共信息的名称即可，配置中心将在模板替换时自动映射公共信息文件上的内容。

为了简化系统设计，周末演练环境的配置数据由环境号进行区分

## 2.2 rpc接口数据模型

### 2.2.1 CfgReq

所有rpc请求的请求结构体均使用CfgReq，其内部结构之间的关系已在1.2.1节中给出，下面给出各个字段的含义

#### 2.2.1.1 CfgReq

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| UserName |    string     | 当前操作者的用户名 |
|  Target   | string[] |   指令字符串数组，具体介绍后文详述   |
| File | byte[] | 导入文件时使用 |
| CfgVersion | CfgVersion[] | 版本层面结构体数组 |

#### 2.2.1.2 CfgVersion

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| Version |    string     | 版本号 |
| Envs | Environment[] | 环境层面结构体数组 |

#### 2.2.1.3 Environment

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| Num |    string     | 环境号 |
| Clusters | Cluster[] | 集群层面结构体数组 |

#### 2.2.1.4 Cluster

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| ClusterName |    string     | 集群名称 |
| Nodes | Node[] | 节点层面结构体数组 |

#### 2.2.1.5 Node

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| GlobalId |    string     | 节点号，全局唯一 |
| LocalId | string | 集群内编号，集群内唯一 |
| Template | string | 生成时选择模板的名称 |

#### 2.2.1.6 Target字段和接口、功能实现的对照表

Target字段主要用于资源定位，其类型为字符串数组，能够简洁地实现需求，且具备良好的可扩展性

下表列出了各个功能点中Target关键字应当如何设置：

|     实现功能    |      接口      |      Target(默认为单字符串)     | 说明 |
| :------------: | :-----------: | :-------------: | :-------------: |
| 获取节点配置文件 |      GET       | "nodeConfig" | 需要将CfgReq构造到节点层级 |
| 获取集群模板组 |      GET       | "templates" | 需要将CfgReq构造到集群层级 |
| 获取集群服务清单 |      GET       | "services" | 需要将CfgReq构造到集群层级 |
| 获取集群工作流程文件组 |      GET       | "manipulations" | 需要将CfgReq构造到集群层级 |
| 获取集群部署信息 |      GET       | "deploymentInfo" | 需要将CfgReq构造到集群层级 |
| 获取公共信息文件 |      GET       | "infrastructure" | 需要将CfgReq构造到版本层级 |
| 获取所有版本号 |      GET       | "versions" |    |
| 获取所有环境号 |      GET       | "environments" | 需要将CfgReq构造到版本层级 |
| 获取所有集群名称 |      GET       | "clusters" | 需要将CfgReq构造到环境层级 |
| 单条信息查询 |      GET       |  "ctlFind"  |  |
|   导入配置   |      PUT       |   |   |
| 删除缓存配置 |      DELETE       |   |   |
|  提交版本   |      POST       |  目标版本号(可为空)  |   |

### 2.2.2 CfgResp

CfgResp结构体由三个字段组成：

- Status: 字符串类型，返回请求处理结果（“ok”或具体的错误内容）
- SliceData: 字符串数组类型，若进行层级查询，则在该字段中返回结果，例如查询当前版本下的所有环境号
- FileData: 字节流类型，若导出文件，则在该字段中返回结果。**除开请求单个节点配置的情况**，其他情况下统一将文件压缩成.tar.gz返回

## 2.3 存储结构

etcd中的键值对如下表所示，其中*前缀表示取该变量的实际值，[]后缀代表该变量的一系列值的集合组成的逗号分隔字符串：
| key | value | 说明 |
|:-----------------:|:------------------:|:-------------:|
| versions | version[] | version[]代表所有版本的序列，该序列有序 |
| *version/envs | envs[] | envs[]代表某一版本下的所有环境号 |
| *version/*env/clusters | clusters[] |clusters[]代表某一环境号下所有集群名称|
| *version/infrastructure.json | content | 某版本下的公共信息文件 |
| *version/*env/*cluster/serviceList.json | content | 某集群的服务清单 |
| *version/*env/*cluster/manipulations/*name | content | 某集群的工作流程文件 |
| *version/*env/*cluster/templates/*name | content | 某集群的配置模板，可存在多份 |

# 3 工作顺序图

## 3.1 配置获取

### 3.1.1 层级获取

![alt](svg/配置获取.svg)

### 3.1.2 文件获取

![alt](svg/文件获取.svg)

## 3.2 配置缓存

暂不单独提供缓存服务，仅在配置导入时自动缓存。在缓存配置时将对用户上传的配置数据进行校验，其流程如下：

![alt](svg/缓存流程图.svg)

## 3.3 删除缓存配置

![alt](svg/删除缓存配置.svg)

## 3.4 版本提交

![alt](svg/版本提交.svg)

## 3.5 导入配置

![alt](svg/导入配置.svg)

## 3.6 导出配置

![alt](svg/导出配置.svg)

# 4 rpc接口示例

为方便描述，本节中使用json结构体表示请求结构体进行演示

## 4.1 GET

GET接口与Target关键字的联系非常密切，下表给出了与GET接口有关的功能实现中Target关键字的用法：

|     实现功能    |      接口      |      Target(默认为单字符串)     | 说明 |
| :------------: | :-----------: | :-------------: | :-------------: |
| 获取节点配置文件 |      GET       | "nodeConfig" | 需要将CfgReq构造到节点层级 |
| 获取集群模板组 |      GET       | "templates" | 需要将CfgReq构造到集群层级 |
| 获取集群服务清单 |      GET       | "services" | 需要将CfgReq构造到集群层级 |
| 获取集群工作流程文件组 |      GET       | "manipulations" | 需要将CfgReq构造到集群层级 |
| 获取集群部署信息 |      GET       | "deploymentInfo" | 需要将CfgReq构造到集群层级 |
| 获取公共信息文件 |      GET       | "infrastructure" | 需要将CfgReq构造到版本层级 |
| 获取所有版本号 |      GET       | "versions" |    |
| 获取所有环境号 |      GET       | "environments" | 需要将CfgReq构造到版本层级 |
| 获取所有集群名称 |      GET       | "clusters" | 需要将CfgReq构造到环境层级 |
| 单条信息查询 |      GET       |  "ctlFind"  |  |

### 4.1.1 获取节点配置文件

用户构建CfgReq到节点层级，并使用Target字段指明要导出的是"nodeConfig"。例如，下列请求体表示请求配置中心使用DTP.MC.set0.toml模板，生成00环境下DTP.MC.set0集群中，第3个实例的配置文件

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"nodeConfig",
    "File": {
      "FileName":"",
      "FileData":"" 
    },
    "CfgVersions":[
      {
        "Version":"0.0.1",
        "Envs":[
         {
           "Num":"00",
           "Clusters":[
             {
               "ClusterName":"DTP.MC.set0",
               "Nodes":[
                 {
                   "GlobalId":"352",
                   "LocalId":"3",
                   "Template":"DTP.MC.set0.toml",
                 }
               ]
             }
           ]
         }
        ]
      }
    ]
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[],  //返回文件时此项为空
  "File": {
    "FileName":"DTP.MC.set0.toml", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

### 4.1.2 获取集群模板组

用户构建CfgReq到集群层级，并使用Target字段指明要导出的是"templates"。例如，下列请求体表示请求配置中心返回00环境下，DTP.MC.set0集群中，所有的配置模板

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"templates",
    "File": {
      "FileName":"",
      "FileData":"" 
    },
    "CfgVersions":[
      {
        "Version":"0.0.1",
        "Envs":[
         {
           "Num":"00",
           "Clusters":[
             {
               "ClusterName":"DTP.MC.set0",
               "Nodes":[]
             }
           ]
         }
        ]
      }
    ]
  }
}
```

假设返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[],  //返回文件时此项为空
  "File": {
    "FileName":"DTP.MC.set0.templates.tar.gz", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

### 4.1.3 获取集群工作流程文件组

用户构建CfgReq到集群层级，并使用Target字段指明要导出的是"manipulations"。例如，下列请求体表示请求配置中心返回00环境下，DTP.MC.set0集群中，所有的启动文件

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"manipulations",
    "File": {
      "FileName":"",
      "FileData":"" 
    },
    "CfgVersions":[
      {
        "Version":"0.0.1",
        "Envs":[
         {
           "Num":"00",
           "Clusters":[
             {
               "ClusterName":"DTP.MC.set0",
               "Nodes":[]
             }
           ]
         }
        ]
      }
    ]
  }
}
```

假设返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[],  //返回文件时此项为空
  "File": {
    "FileName":"DTP.MC.set0.manipulation.tar.gz", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

### 4.1.4 获取公共信息文件

用户构建CfgReq到版本层级，并使用Target字段指明要导出的是"infrastructure"。例如，下列请求体表示请求配置中心返回0.0.1版本下的所有公共信息文件

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"infrastructure",
    "File": {
      "FileName":"",
      "FileData":"" 
    },
    "CfgVersions":[
      {
        "Version":"0.0.1",
        "Envs":[]
      }
    ]
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[],  //返回文件时此项为空
  "File": {
    "FileName":"DTP.MC.set0.infrastructure.tar.gz", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

### 4.1.5 获取所有版本号

用户构建CfgReq到CfgReq层级，并使用Target字段指明要导出的是"versions"。例如，下列请求体表示请求配置中心返回0.0.1版本下的所有公共信息文件

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"versions",
    "File": {
      "FileName":"",
      "FileData":"" 
    },
    "CfgVersions":[]
  }
}
```

假设当前共有两个版本，v0.0.1和v0.0.2，则返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":["0.0.1","0.0.2"],
  //返回层级数据时该项为空
  "File": {
    "FileName":"", 
    "FileData":
  }
}
```

### 4.1.6 获取所有环境号

与4.1.4节相似，只需改变构建层级和Target关键字即可，不再赘述

### 4.1.7 获取所有集群名称

与4.1.4节相似，只需改变构建层级和Target关键字即可，不再赘述

### 4.1.8 基于网页前端的go template单条信息查询

用户Target字段设为“ctlFind”，并构建一个“文件”，其内容为CtlFind函数。例如，下列请求体表示请求配置中心查询00环境下DTP.MC.set0集群的服务清单中，deployment_hosts服务的值

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"ctlFind",
    "File": {
      "FileName":"find.txt", 
      "FileData":{{CtlFind "servicelist" "1.0.0" "00" "EzEI.set0" "deployment_hosts"}}
    },
    "CfgVersions":[]
  }
}
```

假设其服务清单中有：

```json
{
  //上下文已省略
  "deployment_hosts":["host1.oplan","host2.oplan","host3.oplan"]
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":["host1.oplan","host2.oplan","host3.oplan"],
  //返回层级数据时该项为空
  "File": {
    "FileName":"", 
    "FileData":
  }
}
```

### 4.1.9 获取集群部署信息

用户构建CfgReq到集群层级，并使用Target字段指明要导出的是"deploymentInfo"。例如，下列请求体表示请求配置中心返回00环境下，DTP.MC.set0集群的部署信息

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"deploymentInfo",
    "File": {
      "FileName":"",
      "FileData":"" 
    },
    "CfgVersions":[
      {
        "Version":"0.0.1",
        "Envs":[
         {
           "Num":"00",
           "Clusters":[
             {
               "ClusterName":"DTP.MC.set0",
               "Nodes":[]
             }
           ]
         }
        ]
      }
    ]
  }
}
```

假设返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[],  //返回文件时此项为空
  "File": {
    "FileName":"DTP.MC.set0.deploymentInfo.json", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

## 4.2 PUT

PUT接口负责导入一组配置文件。

用户构建CfgReq到CfgReq层级。例如，下列请求体表示请求配置中心缓存用户someBody的配置文件

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"",
    "File": {
      "FileName":"CfgFile.tar.gz", 
      "FileData"://字节流数据
    },
    "CfgVersions":[]
  }
}
```

则返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[],
  "File": {
      "FileName":"", 
      "FileData":
  }
}
```

## 4.3 DELETE

DELETE用于删除用户缓存的配置信息，当前仅支持全部删除。

用户构建CfgReq到CfgReq层级。例如，下列请求体表示请求配置中心删除用户someBody缓存的配置

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"",
    "File": {
      "FileName":"", 
      "FileData":
    }, 
    "CfgVersions":[]
  }
}
```

则返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[],
  "File": {
      "FileName":"", 
      "FileData":
  }
}
```

## 4.4 POST

POST接口用于提交版本。用户构建CfgReq到CfgReq层级。例如，下列请求体表示请求配置中心提交用户someBody缓存的配置

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"",
    "File": {
      "FileName":"", 
      "FileData":
    }, 
    "CfgVersions":[]
  }
}
```

假设本次提交创建的版本号为0.0.3，则返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":["0.0.3"],
  "File": {
      "FileName":"", 
      "FileData":
  }
}
```

用户也可在Target字段中指定本次提交的版本号。配置中心在检测到版本号不冲突后将以该版本号提交，否则返回一个错误提示

# 5.命令行工具

## 5.1 客户端cfgtool及相关命令

客户端命令行工具可用于从服务端获取生成的配置文件，也可用于获取服务端的服务清单、公共信息文件、配置模板、集群工作流程文件等，还可用于单条信息查询。

### 5.1.1 create online

```shell
Generate configfile partly or totoally online. 
With assigned Arg "--pathin/-i", configfile will be generated by local template and remote serviceInfo
With default Arg "--pathin/-i", configfile will be generated by remote

Usage:
  cfgtool create online [flags]

Examples:
$ ./cfgtool create online --version 1.0.0 --env 00 --cluster EzEI.set0 --globalid 141 --localid 3 --pathin /etc/configcenter/template00 --pathout /etc/configcenter
$ ./cfgtool create online -v 1.0.0 -e 00 -c EzEI.set0 -g 141 -l 3 -o /etc/configcenter

Flags:
  -h, --help            help for online
  -i, --pathin string   assign input path of local template

Global Flags:
  -c, --cluster string    assign a cluster name(required)
  -e, --env string        assign an environment number(required)
  -g, --globalid string   assign a globalId(required)
  -l, --localid string    assign a localId within cluster(required)
  -o, --pathout string    assign output path, which default is pathin
  -u, --user string       current userName(required)
  -v, --version string    assign a config version(required)
```

### 5.1.2 create offline

```shell
Generate configfile under mode offline

Usage:
  cfgtool create offline [flags]

Examples:
$ ./cfgtool create offline --version 1.0.0 --env 00 --cluster EzEI.set0 --globalid 141 --localid 3 --pathin /etc/configcenter/configure.tar.gz --pathout /etc/configcenter
$ ./cfgtool create offline -v 1.0.0 -e 00 -c EzEI.set0 -g 141 -l 3 -i /etc/configcenter/configure.tar.gz -o /etc/configcenter

Flags:
  -h, --help            help for offline
  -i, --pathin string   assign input path of compressedfile(required)

Global Flags:
  -c, --cluster string    assign a cluster name(required)
  -e, --env string        assign an environment number(required)
  -g, --globalid string   assign a globalId(required)
  -l, --localid string    assign a localId within cluster(required)
  -o, --pathout string    assign output path, which default is pathin
  -u, --user string       current userName(required)
  -v, --version string    assign a config version(required)
```

### 5.1.3 get

```shell
get file from remote, the target can be templates, servicelist, pubilcinfo, maniputation

Usage:
  cfgtool get [flags]

Examples:
$ ./cfgtool get --target servicelist --version 1.0.0 --env 00 --cluster EzEI.set0 --pathout /home/someuser
$ ./cfgtool get -t infrastructure -v 1.0.0 -e 00 -c EzEI.set0 -o /home/someuser

Flags:
  -c, --cluster string   assign a cluster name
  -e, --env string       assign an environment number
  -h, --help             help for get
  -o, --pathout string   assign output path(required)
  -t, --target string    assign file type needed(required)
  -v, --version string   assign a config version(required)

Global Flags:
  -u, --user string   current userName(required)
```

### 5.1.4 find

```shell
find particular info from target, result will be presented on cmdline
the params of func CtlFind is (Target, version, env, cluster, service)
please input "" to the param not used

Usage:
  cfgtool find [flags]

Examples:
$ ./cfgtool find --phrase "{{CtlFind(\"servicelist\" \"1.0.0\" \"00\" \"EzEI.set0\" \"MUDP_IP\")}}"" --pathout /home/someuser
$ ./cfgtool find -p "{{CtlFind(\"infrastructure\" \"1.0.0\" \"\" \"\" \"hostName1_IP\")}}" -o /home/someuser

Flags:
  -h, --help             help for find
  -o, --pathout string   assign output path(required)
  -p, --phrase string    phrase as go template format

Global Flags:
  -u, --user string   current userName(required)
```

### 5.1.5 delete

```shell
using this command to delete ALL configfiles under the selected username

Usage:
  cfgtool delete [flags]

Flags:
  -h, --help   help for delete

Global Flags:
  -u, --user string   current userName(required)
```

### 5.1.6 put

```shell
put command enables you to save config file under your username on remote
attention that the configfile would not be submit.
learn more about that on command "post"

Usage:
  cfgtool put [flags]

Flags:
  -h, --help            help for put
  -i, --pathin string   assign input path of compressedfile(required)

Global Flags:
  -u, --user string   current userName(required)
```

### 5.1.7 post

```shell
post command is used for submit the configfile under the username selected.
you can either assign version number in flag --version or leave it as default
attention that you have to put configfile first

Usage:
  cfgtool post [flags]

Flags:
  -h, --help             help for post
  -v, --version string   put version number here if you want

Global Flags:
  -u, --user string   current userName(required)

```

## 5.2 服务端cfgsrv及相关命令

服务端命令行工具主要用于调试阶段，用于修改、删除部分或全部数据

### 5.2.1 modify

todo:用于修改或删除单条服务信息、公共信息，触发校验逻辑。

### 5.2.2 clearall

todo:删库，**仅用于调试，生产环境下将关闭该端口！**

# 6.项目测试

## 6.1 单元测试

TODO

## 6.2 性能测试

TODO

## 6.3 模糊测试

TODO

# 7.部署设计

TODO

# 8.容灾设计

TODO

# 补充说明

## 词汇表

|    名词    |    释义    |        特殊说明        |
| :--------: | :-------------------: | :----------------: |
| 配置数据 | 与配置相关的数据，包括配置模板、服务清单、工作流程文件、公共信息文件、配置文件中的一项或多项 |        |
| 配置模板 | 包含固定配置信息以及可替换信息的文件 |  |
| 配置模板组 | 以应用集群为单位的一组配置模板 ||
| 配置文件 | 使用模板生成后的可用的配置文件 |  文件数量根据语境确定  |
| 服务清单 | 以集群为单位，包含该集群下所有服务的名称和内容的单个文件 |  |
| 工作流程文件 | 以集群为单位，包含操控中心启动该集群的流程信息 ||
| 服务信息 | 服务清单上的信息 |  |
| 公共信息文件 | 同一版本内的节点共享的信息，如物理设施信息 | |
| 前端 | 指配置中心前端，包含网页版和命令行工具 |           |
| 用户名 | 前端进行操作的用户的名称 |    |
| 自动化系统 | 需要从配置中心拉取配置的自动运行的系统，如操控中心 | |
| 应用集群 | 在同一环境下可以使用同一配置模板组生成配置文件的一组节点 | 以逻辑功能划分 |

## 配置中心升级

配置中心借助独立于服务端应用程序之外的一个etcd集群实现存储，因此服务程序可以在方便时关闭、升级、重启，无需采取特殊措施。建议以7天*24小时的模式运行。

## 关于导入的配置数据的要求

当前要求导入完整的全量配置信息压缩包，以实现对某一环境内的配置模板和服务清单的校验功能。

## 模板函数

### GetInfo(implicitIndex bool, clusterName string, serviceName string)(string,error)

该函数是配置中心推荐在模板中使用的函数。用户在集群的配置模板中输入依赖的集群名称和服务名称，配置中心根据输入的参数获取相应的服务并填充。

函数返回string类型的填充结果。当执行错误或填充值为空字符串时，函数返回错误信息。

该函数体现了配置中心的设计思想，即希望进行良好的用户侧逻辑划分，按照环境号隔离生产、测试等环境，严防误操作，同时避免逻辑混乱。

### CtlFind(target, version, env, cluster, service string)(string, error)

该函数用于在命令行工具中在全局范围内查询单条信息。

函数返回string类型的填充结果。当执行错误或填充值为空字符串时，函数返回错误信息。

值得注意的是，该函数不会执行服务信息到公共信息的映射，函数返回直接的查询结果并在命令行输出。

### UnsafeGetInfo(implicitIndex bool, version, env, cluster, service string)(string, error)

该函数仅用于在测试环境和紧急情况下进行模板生成。跨版本和环境的操作是不推荐的，这将带来风险。

该函数与CtlFind的区别在于，该函数仍会执行服务信息到公共信息的映射，依赖的公共信息文件由version决定
