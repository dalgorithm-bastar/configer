- [1. 总体设计](#1-总体设计)
  - [1.1 整体视图](#11-整体视图)
  - [1.2 服务端逻辑划分](#12-服务端逻辑划分)
    - [1.2.1 模块关系图](#121-模块关系图)
    - [1.2.2 接口模块](#122-接口模块)
    - [1.2.3 处理模块](#123-处理模块)
      - [1.2.3.1 管理模块manage](#1231-管理模块manage)
      - [1.2.3.2 生成模块template](#1232-生成模块template)
      - [1.2.3.3 日志模块log](#1233-日志模块log)
      - [1.2.3.4 辅助模块util](#1234-辅助模块util)
    - [1.2.4 存储模块](#124-存储模块)
  - [1.3 整体流程图](#13-整体流程图)
  - [1.4 设计约束](#14-设计约束)
- [2 数据模型](#2-数据模型)
  - [2.1 配置数据层级划分](#21-配置数据层级划分)
  - [2.2 rpc接口数据模型](#22-rpc接口数据模型)
    - [2.2.1 CfgReq](#221-cfgreq)
      - [2.2.1.1 CfgReq](#2211-cfgreq)
      - [2.2.1.2 AnyFile](#2212-anyfile)
      - [2.2.1.3 Target字段和接口、功能实现的对照表](#2213-target字段和接口功能实现的对照表)
      - [2.2.1.4 Action字段和接口、功能实现的对照表](#2214-action字段和接口功能实现的对照表)
      - [2.2.1.5 Type字段和接口、功能实现的对照表](#2215-type字段和接口功能实现的对照表)
      - [2.2.1.6 ArgRange字段](#2216-argrange字段)
    - [2.2.2 CfgResp](#222-cfgresp)
    - [2.2.3 修改动作缓存表ChangeList](#223-修改动作缓存表changelist)
  - [2.3 存储结构](#23-存储结构)
- [3 工作顺序图](#3-工作顺序图)
  - [3.1 配置获取](#31-配置获取)
    - [3.1.1 层级获取](#311-层级获取)
    - [3.1.2 文件获取](#312-文件获取)
  - [3.2 配置缓存](#32-配置缓存)
  - [3.3 删除缓存配置](#33-删除缓存配置)
  - [3.4 版本提交](#34-版本提交)
  - [3.5 导入配置](#35-导入配置)
  - [3.6 导出配置](#36-导出配置)
- [4 rpc接口示例](#4-rpc接口示例)
  - [4.1 GET](#41-get)
    - [4.1.1 获取生成后的配置文件数据包](#411-获取生成后的配置文件数据包)
    - [4.1.2 获取节点原始数据](#412-获取节点原始数据)
    - [4.1.3 获取基础设施信息文件](#413-获取基础设施信息文件)
    - [4.1.4 获取所有版本号](#414-获取所有版本号)
  - [4.2 PUT](#42-put)
    - [4.2.1 缓存对部署信息的修改](#421-缓存对部署信息的修改)
    - [4.2.2 缓存对配置数据的修改](#422-缓存对配置数据的修改)
  - [4.3 COMMIT](#43-commit)
    - [4.3.1 提交缓存的配置数据](#431-提交缓存的配置数据)
    - [4.3.2 提交基础设施信息](#432-提交基础设施信息)
  - [4.4 DELETE](#44-delete)
- [5.命令行工具](#5命令行工具)
  - [5.1 客户端cfgtool及相关命令](#51-客户端cfgtool及相关命令)
    - [5.1.1 create online](#511-create-online)
    - [5.1.2 create offline](#512-create-offline)
    - [5.1.3 get](#513-get)
    - [5.1.4 find](#514-find)
    - [5.1.5 delete](#515-delete)
    - [5.1.6 put](#516-put)
    - [5.1.7 post](#517-post)
  - [5.2 服务端cfgsrv及相关命令](#52-服务端cfgsrv及相关命令)
    - [5.2.1 modify](#521-modify)
    - [5.2.2 clearall](#522-clearall)
- [6.项目测试](#6项目测试)
  - [6.1 单元测试](#61-单元测试)
  - [6.2 性能测试](#62-性能测试)
  - [6.3 模糊测试](#63-模糊测试)
- [7.部署设计](#7部署设计)
- [8.容灾设计](#8容灾设计)
- [9.补充说明](#9补充说明)
  - [词汇表](#词汇表)
  - [配置中心升级](#配置中心升级)
  - [关于导入的配置数据的要求](#关于导入的配置数据的要求)
  - [模板函数](#模板函数)
    - [GetInfo(implicitIndex bool, clusterName string, serviceName string)(string,error)](#getinfoimplicitindex-bool-clustername-string-servicename-stringstringerror)
    - [CtlFind(target, version, env, cluster, service string)(string, error)](#ctlfindtarget-version-env-cluster-service-stringstring-error)
    - [UnsafeGetInfo(implicitIndex bool, version, env, cluster, service string)(string, error)](#unsafegetinfoimplicitindex-bool-version-env-cluster-service-stringstring-error)
- [10.附录](#10附录)
  - [*修改记要(v1.0->v1.1)](#修改记要v10-v11)

# 1. 总体设计

配置中心对交易系统的各个集群的配置信息实行集中的、版本化的管理，各个集群需要向配置中心提供自身的服务清单和配置模板，配置中心解析各集群的服务清单，校验模板上要求替换的服务信息是否存在，并根据模板生成各个节点的配置文件。

上传配置数据时，应当以版本为单位附带一份公共信息文件。该文件记录较为基础和底层的信息，如物理机信息等。服务清单上，服务名称对应的值可以使用公共信息的名称，配置中心在填充模板时将自动替换为公共信息文件上对应的值

## 1.1 整体视图

配置中心由前端(包含命令行与网页端)、服务端和存储端组成。其中网页端借助envoy实现http与grpc之间的代理转发。其结构图如下：

![alt](svg/总体架构.svg)

在交易系统启动前，配置中心与操控中心进行交互，无需人工干预，其工作流程大致如下：

![alt](svg/操控中心交互.svg)

配置数据的版本更新等操作在配置中心网页前端完成，命令行工具仅在调试和紧急情况下使用

## 1.2 服务端逻辑划分

按照逻辑功能的不同，可将配置中心分为接口模块(package pb)、处理模块(package manage,package template,package util,package log)和存储模块(package storage)

### 1.2.1 模块关系图

![alt](svg/包图.svg)

### 1.2.2 接口模块

配置中心服务端使用grpc实现一组接口，完成对外交互的需求。接口包含GET、PUT、POST和DELETE，接口行为与语义一致。配置中心的所有接口使用统一的请求结构体CfgReq和返回结构体CfgResp。

服务端接口由管理模块的Manager类实现，类图如下：

![alt](svg/处理模块.svg)

### 1.2.3 处理模块

处理模块包含管理模块manage、生成模块template、日志模块log、辅助模块util

#### 1.2.3.1 管理模块manage

管理模块负责直接处理接口模块接收的外部请求，并实现处理逻辑。管理模块不负责功能的具体实现，如储存和读取、模板的生成等，这些功能通过调用其他模块的接口实现。在处理完成后，管理模块负责将处理结果和请求结果返回接口模块。

#### 1.2.3.2 生成模块template

负责实现模板的填充。该模块维护一个模板对象，并根据需要把配置模板注册到模板对象中。填充模板时，通过模块内的一组预设的函数来实现，预设函数的详情在说明部分给出。该模块类图如下：

![alt](svg/生成模块.svg)

#### 1.2.3.3 日志模块log

该模块负责管理可供其他模块调用的结构化日志对象和格式化日志对象。其类图如下：

![alt](svg/日志模块.svg)

#### 1.2.3.4 辅助模块util

该模块负责实现一组工具函数，实现文件的压缩和解压、字符串操作等辅助功能。包内包含两个源文件fileUtil.go和stringUtil.go，分别实现针对文件和字符串的相关功能。

### 1.2.4 存储模块

存储模块分为repository接口层和datasource实现层。接口名称为Storage，其中定义了数据操作接口，datasource中分别定义了针对etcd和本地压缩包的实现类EtcdType和CompressedFileType，整个模块的类图如下：

![alt](svg/存储模块.svg)

## 1.3 整体流程图

![alt](svg/整体流程图.svg)

## 1.4 设计约束

由于当前交易系统使用的配置文件格式多样、结构各异，因此配置中心不对具体的配置进行key-value存储，即配置中心不解析各个集群的配置模板。但配置中心提供基于go template的查询函数，用户可对单条信息进行查询

配置中心采用模板生成的方式，在当前实际限制下实现服务管理和配置文件生成。

# 2 数据模型

## 2.1 配置数据层级划分

下图给出了配置中心数据的层级关系：

![alt](svg/信息层级.svg)

一个用于示例的配置文件数据包树状结构为：

```shell
.
├── 0.0.1
│   ├── scheme1
│   │   ├── deployment
│   │   │   ├── DTP
│   │   │   │   ├── MC
│   │   │   │   │   ├── setx
│   │   │   │   │   │   └── deployment.json
│   │   │   │   │   └── sety
│   │   │   │   │       └── deployment.json
│   │   │   │   └── RC
│   │   │   │       ├── seta
│   │   │   │       │   └── deployment.json
│   │   │   │       └── setb
│   │   │   │           └── deployment.json
│   │   │   └── MTP
│   │   ├── service
│   │   │   ├── DTP
│   │   │   │   ├── MC
│   │   │   │   │   ├── engine1
│   │   │   │   │   │   └── service.json
│   │   │   │   │   ├── engine2
│   │   │   │   │   │   └── service.json
│   │   │   │   │   └── service.json
│   │   │   │   └── RC
│   │   │   │       ├── engine1
│   │   │   │       │   └── service.json
│   │   │   │       ├── engine2
│   │   │   │       │   └── service.json
│   │   │   │       └── service.json
│   │   │   └── MTP
│   │   └── template
│   │       ├── DTP
│   │       │   ├── MC
│   │       │   │   ├── app_shl.toml
│   │       │   │   ├── biz_engine
│   │       │   │   │   ├── matcher_so
│   │       │   │   │   │   └── matcher_config.toml
│   │       │   │   │   └── riskcontrol_so
│   │       │   │   │       └── risk_control_config.toml
│   │       │   │   └── component
│   │       │   │       ├── data_engine.toml
│   │       │   │       ├── event_framework.toml
│   │       │   │       └── logger.toml
│   │       │   └── RC
│   │       │       ├── app_shl.toml
│   │       │       ├── biz_engine
│   │       │       │   ├── matcher_so
│   │       │       │   │   └── matcher_config.toml
│   │       │       │   └── riskcontrol_so
│   │       │       │       └── risk_control_config.toml
│   │       │       └── component
│   │       │           ├── data_engine.toml
│   │       │           ├── event_framework.toml
│   │       │           └── logger.toml
│   │       └── MTP
│   └── scheme2
└── infrastructure
    └── infrastructure.json
```

## 2.2 rpc接口数据模型

### 2.2.1 CfgReq

所有rpc请求的请求结构体均使用CfgReq，其内部结构之间的关系已在1.2.1节中给出，下面给出各个字段的含义

#### 2.2.1.1 CfgReq

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| UserName |    string     | 当前操作者的用户名 |
|  Target   | string[] |   指令字符串，用于区分要获取的目标的类型   |
| Action | string | 指令字符串，用于描述修改动作 |
| EnvNum | string | 环境号 |
| File | AnyFile | 用于存放要提交的文件 |
| Version | string | 目标版本号 |
| Scheme | string | 目标配置方案 |
| Type | string | 目标信息类型 |
| Platform | string | 目标平台 |
| NodeType | string | 目标节点类型 |
| Set | string | 目标集群 |
| ArgRange | ArgRange | 输入ip、port范围 |

#### 2.2.1.2 AnyFile

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| FileName |    string     | 文件名 |
|  Content   | byte[] |   文件内容   |

#### 2.2.1.3 Target字段和接口、功能实现的对照表

Target字段主要用于确定要获取的资源种类，其类型为字符串，具备良好的可扩展性。

下表列出了各个功能点中Target关键字应当如何设置：

|     实现功能    |      接口      |      Target    | 说明 |
| :------------: | :-----------: | :-------------: | :-------------: |
| 获取生成的所有配置文件 |      GET       | "config" |  |
| 获取基础设施信息文件 |      GET       | "infra" |  |
| 获取所有版本号 |      GET       | "version" |   |
| 获取原始数据 |      GET       | "raw" |   |
| 获取用户缓存的数据 | GET | "cache" |  |
|  缓存配置数据   |      PUT       |  "raw"  | 目标版本号放在Version字段 |
|  提交基础设施信息文件   |      COMMIT       |  "infra"  |  |

#### 2.2.1.4 Action字段和接口、功能实现的对照表

Action字段主要用于限定更新范围，其类型为字符串。

下表列出了各个功能点中Action关键字应当如何设置：

|     实现功能    |      接口      |      Action     | 说明 |
| :------------: | :-----------: | :-------------: | :-------------: |
|  缓存配置数据   |      PUT       |  "ResetAtRoot"  |  在版本范围内全量更新，必须上传符合格式要求的配置数据包，必须配合其他请求参数  |
|  缓存配置数据   |      PUT       |  "ResetAtLeaf"  |  在其他参数限定的范围内全量更新  |
|  缓存配置数据   |      PUT       |  "AddAndReplaceAtLeaf"  |  在其他参数限定的范围内增量更新(允许文件重名，重名即覆盖原文件)  |
| 缓存配置数据 | PUT | "AddButNoReplaceAtLeaf" | 在其他参数限定的范围内增量更新(重名时不覆盖原文件) |

#### 2.2.1.5 Type字段和接口、功能实现的对照表

Type字段用于指定树状结构中的一层，但具有特殊限制，其用法如下：

|     实现功能    |      接口      |      Type     | 说明 |
| :------------: | :-----------: | :-------------: | :-------------: |
|  提交配置数据   |      PUT       |  "deployment"  | 更新部署信息 |
|  提交配置数据   |      PUT       |  "service"  |  更新服务信息  |
|  提交配置数据   |      PUT       |  "template"  |  更新配置模板  |
| 获取原始数据 |      GET       | "deployment" | 获取部署信息 |
| 获取原始数据 |      GET       | "service" | 获取服务信息 |
| 获取原始数据 |      GET       | "template" | 获取配置模板 |

#### 2.2.1.6 ArgRange字段

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| TopicIp | []string  | 用于生成组播地址的Ip范围 |
| TopicPort | []string |  用于生成组播地址的端口范围  |

### 2.2.2 CfgResp

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| status | string | "ok"或执行过程中的错误日志 |
| Versions | Version[] | 版本号数组 |
| File | AnyFile | 文件数据 |

其中Version类型结构如下：

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| Name | string | 标准三段式版本号 |
| User | string | 提交该版本号的用户 |
| Time | timestamp | 提交时间的13位时间戳 |

### 2.2.3 修改动作缓存表ChangeList

按照时间顺序缓存用户的修改行为、记录每次行为需要修改的文件，在某些情况下也可以没有文件。在有文件的情况下，文件保存在etcd中。该表结构如下：

```json
{
  "changeList":[
    {
      "stepOrder":1,
      "action":"ResetAtLeaf",
      "level":"scheme1/template/DTP",
      "keysToFile":["Path1","Path2"]
    },
    {
      "stepOrder":2,
      "action":"AddAndReplaceAtLeaf",
      "level":"scheme1/template/DTP/MC",
      "keysToFile":["Path3","Path4"]
    }
  ]
}
```

Path的规则见存储结构。

## 2.3 存储结构

etcd中的键值对如下表所示，其中&前缀表示取该变量的实际值，[]后缀代表该变量的一系列值的集合组成的逗号分隔字符串：
| key | value | 说明 |
|:-----------------:|:------------------:|:-------------:|
| VersionList | string[] | 代表所有版本的序列，该序列有序 |
| &Version/SchemeList | string[] | 代表某版本下配置方案的序列 |
| infrastructure | byte[] | 基础设施信息文件 |
| &Version/&Scheme/&Platform/&NodeType/&Type/&Set/&FileName | byte[] | 某个set下的某份文件 |
| &Version/&Scheme/&Platform/&NodeType/&Type/&FileName | byte[] | 某节点类型下的某份文件|
| &UserName/&StepOrder/&Scheme/&Platform/&NodeType/&Type/&Set/&FileName | byte[] | 用户缓存的某个set下的某份文件 |
| &UserName/&StepOrder/&Scheme/&Platform/&NodeType/&Type/&FileName | byte[] |用户缓存的某节点类型下的某份文件|

# 3 工作顺序图

## 3.1 配置获取

### 3.1.1 层级获取

![alt](svg/配置获取.svg)

### 3.1.2 文件获取

![alt](svg/文件获取.svg)

## 3.2 配置缓存

暂不单独提供缓存服务，仅在配置导入时自动缓存。在缓存配置时将对用户上传的配置数据进行校验，其流程如下：

![alt](svg/缓存流程图.svg)

## 3.3 删除缓存配置

![alt](svg/删除缓存配置.svg)

## 3.4 版本提交

![alt](svg/版本提交.svg)

## 3.5 导入配置

![alt](svg/导入配置.svg)

## 3.6 导出配置

![alt](svg/导出配置.svg)

# 4 rpc接口示例

为方便描述，本节中使用json结构体表示请求结构体进行演示

## 4.1 GET

GET接口可用于从服务端获取信息，包括原始数据（含配置模板、服务信息、部署信息、基础设施信息）和生成后的配置数据包。

### 4.1.1 获取生成后的配置文件数据包

配置文件由配置中心动态生成，因此每次获取配置都是获取生成后的全量的配置文件，其动态分配部分会存在一定差异。返回的文件包含生成的部署信息、生成的配置文件、生成的topicInfo总表。

以下为请求体示例：

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"config",
    "EnvNum":"00",
    "Version":"1.0.0",
    "Scheme":"scheme1",
    "ArgRange":{
      "TopicIp":["10.112.3.5","10.112.5.5"],
      "TopicPort":["1","2376"]
    }
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[],  //返回文件对象时此项为空
  "File": {
    "FileName":"name1", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

返回结构体中FileData的结构为：

```json
res
├── scheme1
│   ├── DTP
│   │   ├── MC
│   │   │   ├── set1
│   │   │   │   └── host1    //文件夹以该节点要部署的主机名称命名
│   │   │   │       ├── app_shl.toml
│   │   │   │       ├── biz_engine
│   │   │   │       │   ├── matcher_so
│   │   │   │       │   │   └── matcher_config.toml
│   │   │   │       │   └── riskcontrol_so
│   │   │   │       │       └── risk_control_config.toml
│   │   │   │       ├── component
│   │   │   │       │   ├── data_engine.toml
│   │   │   │       │   ├── event_framework.toml
│   │   │   │       │   └── logger.toml
│   │   │   │       └── topic_info.json
│   │   │   └── set2
│   │   └── RC
│   └── MTP
├── deployment
│   ├── DTP
│   │   ├── MC
│   │   │   ├── set1
│   │   │   │   └── deployment.json
│   │   │   └── set2
│   │   │       └── deployment.json
│   │   └── RC
│   │       ├── set1
│   │       │   └── deployment.json
│   │       └── set2
│   │           └── deployment.json
│   └── MTP
└── topicInfo.json
```

### 4.1.2 获取节点原始数据

以下请求体表示请求获取版本号1.0.0，配置方案scheme1，平台DTP，节点类型RC，类型template的所有配置文件模板。

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"raw",
    "Version":"1.0.0",
    "Scheme":"scheme1",
    "Platform":"DTP",
    "NodeType":"RC",
    "Type":"template"
  }
}
```

假设返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[],  //返回文件时此项为空
  "File": {
    "FileName":"DTP.RC.templates.tar.gz", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

要获取部署信息文件和服务信息文件，只需修改Type字段为相应的关键字即可。

返回结构体中FileData的结构为：

```json
template
├── app_shl.toml
├── biz_engine
│   ├── matcher_so
│   │   └── matcher_config.toml
│   └── riskcontrol_so
│       └── risk_control_config.toml
└── component
    ├── data_engine.toml
    ├── event_framework.toml
    └── logger.toml
```

### 4.1.3 获取基础设施信息文件

使用Target字段指明要导出的是"infra"。示例如下：

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"infra"
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[],  //返回文件时此项为空
  "File": {
    "FileName":"infrastructure.json", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

### 4.1.4 获取所有版本号

使用Target字段指明要导出的是"version"。例如:

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"version",
  }
}
```

假设当前共有两个版本，v0.0.1和v0.0.2，则返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":["0.0.1","0.0.2"],
  //返回层级数据时该项为空
  "File": {
    "FileName":"", 
    "FileData":
  }
}
```

## 4.2 PUT

PUT接口用于缓存用户单次提交的修改，用户在请求体中用参数限定修改动作的范围，并在上传的配置数据包中提交相应的文件。下面分别就针对部署信息和针对其他配置数据的缓存举例。

### 4.2.1 缓存对部署信息的修改

用户someBody想要重置（reset）DTP.RC.set1层级的部署信息，则应构建请求体如下：

```json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"raw",
    "Action":"ResetAtLeaf",
    "Scheme":"scheme1", //指定配置方案，默认更新在最新版本的配置数据上
    "Platform":"DTP",
    "NodeType":"RC",
    "Type":"template",
    "Set":"set1",
    "File":{
      "FileName":"deployment.json",
      "Content":"content"
    }
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok"
}
```

此处示例为更新单个set，实际情况下可以在节点类型或更高层级进行更新。若在更高层级更新，需构建与配置中心数据包结构一致的上传文件数据包。

### 4.2.2 缓存对配置数据的修改

用户someBody想要更新（AddAndReplaceAtLeaf）DTP.RC层级的**某些**配置模板，则应构建请求体如下：

```json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"raw",
    "Action":"ResetAtLeaf",
    "Scheme":"scheme1", //指定配置方案，默认更新在最新版本的配置数据上
    "Platform":"DTP",
    "NodeType":"RC",
    "Type":"template",
    "File":{
      "FileName":"app_shl.json",
      "Content":"content"
    }
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok"
}
```

在用户提交后，配置中心的配置数据包中RC.template下的app_shl.json文件将被替换。

## 4.3 COMMIT

### 4.3.1 提交缓存的配置数据

COMMIT接口用于提交版本，请求体内的Target关键字设为raw。例如，下列请求体表示请求配置中心提交用户someBody请求上传的配置。

``` json
{
  "CfgReq":{
    "CfgReq":{
      "UserName":"someBody",
      "Target":"raw"
    }
  }
}
```

假设本次提交创建的版本号为0.0.3，则返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "SliceData":[
    {
      "Version":"0.0.3",
      "User":"someBody",
      "Time":""
    }
  ],
  "File": {
      "FileName":"", 
      "FileData":
  }
}
```

用户也可在version字段中指定本次提交的版本号。配置中心在检测到版本号不冲突后将以该版本号提交，否则返回一个错误提示

### 4.3.2 提交基础设施信息

COMMIT接口用于提交基础设施信息，请求体内的Target关键字设为infra。例如，下列请求体表示请求配置中心提交用户someBody请求上传的infrastructure.json。

``` json
{
  "CfgReq":{
    "CfgReq":{
    "UserName":"someBody",
    "Target":"infra",
    "File":{
        "FileName":"infrastructure.json",
        "Content":"content"
      }
    }
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok"
}
```

## 4.4 DELETE

delete接口负责删除用户目录下缓存的修改信息。构建请求体如下：

```json
{
  "CfgReq":{
    "UserName":"someBody"
  }
}
```

则配置中心将用户someBody缓存的修改信息全部删除。

# 5.命令行工具

## 5.1 客户端cfgtool及相关命令

客户端命令行工具可用于从服务端获取生成的配置文件，也可用于获取服务端的服务清单、公共信息文件、配置模板、集群工作流程文件等，还可用于单条信息查询。

### 5.1.1 create online

```shell
Generate configfile partly or totoally online. 
With assigned Arg "--pathin/-i", configfile will be generated by local template and remote serviceInfo
With default Arg "--pathin/-i", configfile will be generated by remote

Usage:
  cfgtool create online [flags]

Examples:
$ ./cfgtool create online --version 1.0.0 --env 00 --cluster EzEI.set0 --globalid 141 --localid 3 --pathin /etc/configcenter/template00 --pathout /etc/configcenter
$ ./cfgtool create online -v 1.0.0 -e 00 -c EzEI.set0 -g 141 -l 3 -o /etc/configcenter

Flags:
  -h, --help            help for online
  -i, --pathin string   assign input path of local template

Global Flags:
  -c, --cluster string    assign a cluster name(required)
  -e, --env string        assign an environment number(required)
  -g, --globalid string   assign a globalId(required)
  -l, --localid string    assign a localId within cluster(required)
  -o, --pathout string    assign output path, which default is pathin
  -u, --user string       current userName(required)
  -v, --version string    assign a config version(required)
```

### 5.1.2 create offline

```shell
Generate configfile under mode offline

Usage:
  cfgtool create offline [flags]

Examples:
$ ./cfgtool create offline --version 1.0.0 --env 00 --cluster EzEI.set0 --globalid 141 --localid 3 --pathin /etc/configcenter/configure.tar.gz --pathout /etc/configcenter
$ ./cfgtool create offline -v 1.0.0 -e 00 -c EzEI.set0 -g 141 -l 3 -i /etc/configcenter/configure.tar.gz -o /etc/configcenter

Flags:
  -h, --help            help for offline
  -i, --pathin string   assign input path of compressedfile(required)

Global Flags:
  -c, --cluster string    assign a cluster name(required)
  -e, --env string        assign an environment number(required)
  -g, --globalid string   assign a globalId(required)
  -l, --localid string    assign a localId within cluster(required)
  -o, --pathout string    assign output path, which default is pathin
  -u, --user string       current userName(required)
  -v, --version string    assign a config version(required)
```

### 5.1.3 get

```shell
get file from remote, the target can be templates, servicelist, pubilcinfo, maniputation

Usage:
  cfgtool get [flags]

Examples:
$ ./cfgtool get --target servicelist --version 1.0.0 --env 00 --cluster EzEI.set0 --pathout /home/someuser
$ ./cfgtool get -t infrastructure -v 1.0.0 -e 00 -c EzEI.set0 -o /home/someuser

Flags:
  -c, --cluster string   assign a cluster name
  -e, --env string       assign an environment number
  -h, --help             help for get
  -o, --pathout string   assign output path(required)
  -t, --target string    assign file type needed(required)
  -v, --version string   assign a config version(required)

Global Flags:
  -u, --user string   current userName(required)
```

### 5.1.4 find

```shell
find particular info from target, result will be presented on cmdline
the params of func CtlFind is (Target, version, env, cluster, service)
please input "" to the param not used

Usage:
  cfgtool find [flags]

Examples:
$ ./cfgtool find --phrase "{{CtlFind(\"servicelist\" \"1.0.0\" \"00\" \"EzEI.set0\" \"MUDP_IP\")}}"" --pathout /home/someuser
$ ./cfgtool find -p "{{CtlFind(\"infrastructure\" \"1.0.0\" \"\" \"\" \"hostName1_IP\")}}" -o /home/someuser

Flags:
  -h, --help             help for find
  -o, --pathout string   assign output path(required)
  -p, --phrase string    phrase as go template format

Global Flags:
  -u, --user string   current userName(required)
```

### 5.1.5 delete

```shell
using this command to delete ALL configfiles under the selected username

Usage:
  cfgtool delete [flags]

Flags:
  -h, --help   help for delete

Global Flags:
  -u, --user string   current userName(required)
```

### 5.1.6 put

```shell
put command enables you to save config file under your username on remote
attention that the configfile would not be submit.
learn more about that on command "post"

Usage:
  cfgtool put [flags]

Flags:
  -h, --help            help for put
  -i, --pathin string   assign input path of compressedfile(required)

Global Flags:
  -u, --user string   current userName(required)
```

### 5.1.7 post

```shell
post command is used for submit the configfile under the username selected.
you can either assign version number in flag --version or leave it as default
attention that you have to put configfile first

Usage:
  cfgtool post [flags]

Flags:
  -h, --help             help for post
  -v, --version string   put version number here if you want

Global Flags:
  -u, --user string   current userName(required)

```

## 5.2 服务端cfgsrv及相关命令

服务端命令行工具主要用于调试阶段，用于修改、删除部分或全部数据

### 5.2.1 modify

todo:用于修改或删除单条服务信息、公共信息，触发校验逻辑。

### 5.2.2 clearall

todo:删库，**仅用于调试，生产环境下将关闭该端口！**

# 6.项目测试

## 6.1 单元测试

TODO

## 6.2 性能测试

TODO

## 6.3 模糊测试

TODO

# 7.部署设计

TODO

# 8.容灾设计

TODO

# 9.补充说明

## 词汇表

|    名词    |    释义    |        特殊说明        |
| :--------: | :-------------------: | :----------------: |
| 配置数据 | 与配置相关的数据，包括配置模板、服务清单、工作流程文件、公共信息文件、配置文件中的一项或多项 |        |
| 配置模板 | 包含固定配置信息以及可替换信息的文件 |  |
| 配置模板组 | 以应用集群为单位的一组配置模板 ||
| 配置文件 | 使用模板生成后的可用的配置文件 |  文件数量根据语境确定  |
| 服务清单 | 以集群为单位，包含该集群下所有服务的名称和内容的单个文件 |  |
| 工作流程文件 | 以集群为单位，包含操控中心启动该集群的流程信息 ||
| 服务信息 | 服务清单上的信息 |  |
| 公共信息文件 | 同一版本内的节点共享的信息，如物理设施信息 | |
| 前端 | 指配置中心前端，包含网页版和命令行工具 |           |
| 用户名 | 前端进行操作的用户的名称 |    |
| 自动化系统 | 需要从配置中心拉取配置的自动运行的系统，如操控中心 | |
| 应用集群 | 在同一环境下可以使用同一配置模板组生成配置文件的一组节点 | 以逻辑功能划分 |

## 配置中心升级

配置中心借助独立于服务端应用程序之外的一个etcd集群实现存储，因此服务程序可以在方便时关闭、升级、重启，无需采取特殊措施。建议以7天*24小时的模式运行。

## 关于导入的配置数据的要求

当前要求导入完整的全量配置信息压缩包，以实现对某一环境内的配置模板和服务清单的校验功能。

## 模板函数

### GetInfo(implicitIndex bool, clusterName string, serviceName string)(string,error)

该函数是配置中心推荐在模板中使用的函数。用户在集群的配置模板中输入依赖的集群名称和服务名称，配置中心根据输入的参数获取相应的服务并填充。

函数返回string类型的填充结果。当执行错误或填充值为空字符串时，函数返回错误信息。

该函数体现了配置中心的设计思想，即希望进行良好的用户侧逻辑划分，按照环境号隔离生产、测试等环境，严防误操作，同时避免逻辑混乱。

### CtlFind(target, version, env, cluster, service string)(string, error)

该函数用于在命令行工具中在全局范围内查询单条信息。

函数返回string类型的填充结果。当执行错误或填充值为空字符串时，函数返回错误信息。

值得注意的是，该函数不会执行服务信息到公共信息的映射，函数返回直接的查询结果并在命令行输出。

### UnsafeGetInfo(implicitIndex bool, version, env, cluster, service string)(string, error)

该函数仅用于在测试环境和紧急情况下进行模板生成。跨版本和环境的操作是不推荐的，这将带来风险。

该函数与CtlFind的区别在于，该函数仍会执行服务信息到公共信息的映射，依赖的公共信息文件由version决定

# 10.附录

## *修改记要(v1.0->v1.1)

|    修改位置    |    改动说明    |
| :--------: | :-------------------: |
| 1.3 | 增加整体流程图 |
| 2.1 | 修改配置数据层级划分 |
| 2.2.1 | 修改请求结构体设计 |
| 2.2.2 | 修改返回结构体设计 |
|2.2.3| 新增修改动作缓存表ChangeList|
| 2.3 | 修改存储结构 |
| 4 | 外部接口更改 |
