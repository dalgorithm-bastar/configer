- [1.配置文件组织和构建规则](#1配置文件组织和构建规则)
  - [1.1 配置版本更新时的交互流程/配置文件生成过程](#11-配置版本更新时的交互流程配置文件生成过程)
    - [1.1.1 交互流程](#111-交互流程)
    - [1.1.2 生成过程](#112-生成过程)
  - [1.2 配置文件主体定义](#12-配置文件主体定义)
  - [1.3 总则](#13-总则)
  - [1.4 公共信息文件](#14-公共信息文件)
  - [1.5 服务清单文件](#15-服务清单文件)
  - [1.6 模板文件](#16-模板文件)
    - [1.6.1 go template基本语法](#161-go-template基本语法)
    - [1.6.2 内置函数](#162-内置函数)
      - [1.6.2.1 GetInfo](#1621-getinfo)
      - [1.6.2.2 UnsafeGetInfo](#1622-unsafegetinfo)
    - [1.6.3 使用内置函数填充配置模板](#163-使用内置函数填充配置模板)
      - [1.6.3.1 获取非部署信息](#1631-获取非部署信息)
      - [1.6.3.2 获取部署信息](#1632-获取部署信息)
  - [1.7 操控流程文件](#17-操控流程文件)
- [2.配置中心命令行工具使用方法](#2配置中心命令行工具使用方法)
  - [2.1 编译](#21-编译)
  - [2.2 使用客户端命令行工具](#22-使用客户端命令行工具)
    - [2.2.1 create offline](#221-create-offline)
    - [2.2.2 create online](#222-create-online)
    - [2.2.3 find](#223-find)
    - [2.2.4 get](#224-get)
    - [2.2.5 delete](#225-delete)
    - [2.2.6 put](#226-put)
    - [2.2.7 post](#227-post)

# 1.配置文件组织和构建规则

## 1.1 配置版本更新时的交互流程/配置文件生成过程

请在充分理解以下内容的情况下阅读后续章节。

### 1.1.1 交互流程

用户使用配置中心网页前端更新配置版本时，在正常情况下，总共需要两步：

- 在本地选定配置文件压缩包，点击”提交“按钮，上传至配置中心。此时配置文件被缓存到用户名下。
- 用户点击”版本更新“按钮，配置中心将用户名下缓存的配置作为新的版本提交，并返回版本号。

### 1.1.2 生成过程

此处仅介绍生成过程，用户需要了解相应文件在过程中扮演的角色

配置中心使用**配置模板**，在**服务清单**中查找模板上要求替换的内容，在获取到内容后，判断该内容是否需要映射到**公共信息文件**上的某一项。如果映射成立，将公共信息文件上的内容填充到配置模板上，否则填充服务清单上查找到的内容。

填充完成后，返回填充好的配置文件

## 1.2 配置文件主体定义

在正常情况下，提交配置时，配置中心服务端接收网页前端提交的配置压缩包并进行处理。用户需要提前在本地构建配置文件压缩包。

配置文件压缩包内应该仅包含一个文件夹，该文件夹内包含本次核心交易系统配置版本升级所需的所有配置文件，这些文件具体可分为四类：

- 公共信息文件，命名固定为infrastructure.json，每个版本有且仅有一份
- 服务清单文件，命名固定为servicelist.json，每个集群有且仅有一份
- 配置模板文件，名称格式无要求
- 操控流程文件，该类型文件与用户无关，用于操控中心启动各个集群

一个用于示例的文件结构如下所示，后续章节将给出详细的构建规则：

```shell
0.0.1
├── 00
│   ├── DTP.MC.set0
│   │   ├── manipulations
│   │   │   └── manipulation.yaml
│   │   ├── servicelist.json
│   │   └── templates
│   │       ├── template1.toml
│   │       └── template2.toml
│   └── EzEI.set1
│       ├── manipulations
│       │   └── manipulation.yaml
│       ├── servicelist.json
│       └── templates
│           ├── template1.toml
│           └── template2.toml
├── 88
│   ├── DTP.MC.set0
│   │   ├── manipulations
│   │   │   └── manipulation.yaml
│   │   ├── servicelist.json
│   │   └── templates
│   │       ├── template_88.toml
│   │       └── template_test.toml
│   └── EzEI.set1
│       ├── manipulations
│       │   └── manipulation.yaml
│       ├── servicelist.json
│       └── templates
│           ├── template_88.toml
│           └── template_test.toml
└── infrastructure.json
```

## 1.3 总则

文件组织规则和总体命名规则有如下几条：

- **建议**：文件夹根目录设置为期望的版本号。注意，该版本号并不会在缓存配置时被记录，用户如有需求，可在版本更新步时附带版本号。
&nbsp;
- **强制**：根目录有且只有一个，多于一个根目录将被视为错误。
&nbsp;
- **强制**：文件夹结构应当按照 根目录/环境号/集群名称 来进行组织，在这个基础上添加内容。在路径中间不得插入其他值。
  正例：0.0.1/00/DTP.MC.set0、0.0.1/88/EzEI.set1
  反例：0.0.1/envs/00/DTP.MC.set0
&nbsp;
- **强制**：tmplates被视为关键字，只允许出现在集群文件夹下，且必须以文件夹名称存在，否则将返回错误。注意，templates1、test_templates等命名是允许的。
  正例：0.0.1/00/DTP.MC.set0/templates/template_test
  反例：templates/00/DTP.MC.set0/templates/template_test
&nbsp;
对服务清单文件和公共信息文件的内容存在以下约束：

- **强制**：某一项的值不能为空，否则将报错。
  正例：TOPIC_TYPE = "1"  
  反例：TOPIC_TYPE = ""
&nbsp;
- **强制**："."是配置中心进行服务名称匹配时的分隔符，因此键值中不允许含有"."。
  正例：MUDP_IP = "10.1.1.2"  
  反例：MUDP.IP = "10.1.1.2"
&nbsp;
- **强制**：压缩包的格式应为tar.gz。
&nbsp;
- **强制**：在版本更新时，若指定版本号，必须满足标准的三段式语义版本号，否则将返回错误
正例："0.1.0"、"2.10086.10"
反例："0.01.0"、"002.s.#"

## 1.4 公共信息文件

- **建议**：公共信息文件中应当存放最为基础的信息，如物理机信息，此外，这些信息是对所有节点可见的，如果某项信息对可见性敏感，则不应将其放于此处。
&nbsp;
- **强制**：公共信息文件在单个版本的文件夹中唯一存在。
&nbsp;
- **强制**：文件路径必须为 根目录/，文件名必须为infrastructure.json。
&nbsp;
- **强制**：文件中不允许出现自定义结构体组成的数组，但可以使用字符串类型的数组作为值。
&nbsp;
- **强制**：文件中与某个主机名称相关的全部信息，应当全部放在以该主机名命名的结构体内。
正例：示例中hostname1、hostname2为主机名称，外层的normal为自定义前置属性，可多层嵌套也可删除。

```json
{
  "normal": {
    "hostname1": {
      "oplan": {
        "ip": "10.0.1.1"
      },
      "biznet": {
        "ip": "192.168.0.1"
      }
    },
    "hostname2": {
      "oplan": {
        "ip": "10.0.1.2"
      },
      "biznet": {
        "ip": "192.168.0.2"
      }
    }
  }
}
```

## 1.5 服务清单文件

- **建议**：服务清单文件中存放某一集群的部署信息和对外发布的服务信息，其他信息不应放置在此处。
&nbsp;
- **强制**：服务清单文件在某一集群所属的文件夹下有且仅有一份。
&nbsp;
- **强制**：服务清单文件的路径应为 根目录/环境号/集群名称/，文件名必须为servicelist.json。
&nbsp;
- **建议**：服务清单文件中，**除部署信息外，不建议使用自定义对象组成的数组**，若使用，则在一份模板的某个替换项中只能固定取到其中一个值。但是，使用字符串类型的数组作为值是允许的。
&nbsp;
- **强制**：部署信息中必须包含集群实例数目，以键值"replicator_number"放置在json文件根目录下。此外，应在根目录下以键值"deployment_info"建立集合，存放部署信息
&nbsp;
- **强制**：集群中每个实例的部署信息**按序对应**匿名数组中的一个结构体
&nbsp;
- **强制**：部署信息必须以匿名数组的形式提供，以便配置中心快速发现信息缺漏错误。取该数组的第几个值由接口中的localId参数决定，一般情况下由操控中心确定，无需用户手动干预。
&nbsp;
- **强制**：匿名数组中的每个元素应当包含一个键值为"hostname"的项，其值为该元素对应的物理主机名称。元素中的其他项，若需要进行映射，必须在值的首尾添加花括号{}，**配置中心强制映射公共信息文件中与该元素内hostname相同的主机的该项信息**

一份符合规范的服务清单文件示例如下：

```json
{
  "replicator_number": "3",
  "deployment_info": [
    {
      "hostname": "hostname1",
      "MUDP_BIND_IP": "{biznet.ip}"
    },
    {
      "hostname": "hostname2",
      "MUDP_BIND_IP": "{biznet.ip}"
    },
    {
      "hostname": "hostname3",
      "MUDP_BIND_IP": "{biznet.ip}"
    }
  ],
  "MUDP_IP": "224.1.0.4",
  "MUDP_NORMAL_PORT": "9999",
  "MUDP_SUPPLEMNET_PORT": "0",
  "MUDP_NOTIFY_PORT": "0",
  "kafka_broker": [
    "179.7.89.3:29092",
    "179.7.89.7:29092",
    "179.7.89.11:29092",
    "179.7.219.4:29092",
    "179.7.219.6:29092"
  ]
}
```

## 1.6 模板文件

模板文件没有格式要求，配置中心也不对其中内容进行解析。

- **强制**：模板文件的路径应为 根目录/环境号/集群名称/templates/，该文件夹下不允许出现子文件夹。模板文件名和文件数量无要求

### 1.6.1 go template基本语法

go template是golang的标准库之一，用于按照一定的规则替换文本中的某些部分。要替换的部分使用双重花括号括起来，其他部分会在进行替换后原封不动地保留。
  示例：

```toml
[rmb_publisher]
TOPIC_TYPE = "1"
HOST = {{GetInfo true "DTP.MC.set0" "deployment_info/host"}} #要替换的部分
```

- **强制**：注释在go template中无效，在构建配置模板时，应直接删除无用项
反例：

```toml
[rmb_publisher]
TOPIC_TYPE = "1"
# HOST = {{GetInfo true "DTP.MC.set0" "deployment_info/host"}} #要替换的部分
# go template仍然会识别该部分内容并加以处理，应当直接删除！！！
```

### 1.6.2 内置函数

内置函数是配置中心提供给用户的一组函数，用户可以在配置模板上使用内置函数获取服务清单上的特定信息

#### 1.6.2.1 GetInfo

用户需要替换时，应当在绝大多数情况下使用该函数

```go
//函数原型
func(defaultIndex bool, clusterObject, service string) (string, error){}
//defaultIndex
//表示是否使用localId作为索引，
//在获取带有自定义数组类型的部署信息时，应设为true，其他场景下应设为false

//clusterObject
//表示目标集群，即要在哪个集群下的服务清单里检索

//service
//将在下一节中已经进行详细说明
```

用法示例：

```toml
[rmb_publisher]
TOPIC_TYPE = "1"
HOST = {{GetInfo true "DTP.MC.set0" "deployment_info/host"}} #要替换的部分
```

#### 1.6.2.2 UnsafeGetInfo

该函数提供跨版本和环境的检索功能，是不安全的，一般情况下不推荐使用

```go
//函数原型
func(defaultIndex bool, anyVersion, anyEnv, clusterObject, service string) (string, error) {}
//anyVersion
//目标版本号，即要在哪个版本下查询

//anyEnv
//目标环境，即要在哪个环境下查询

//其他参数与GetInfo一致
```

用法示例：

```toml
[rmb_publisher]
TOPIC_TYPE = "1"
HOST = {{UnsafeGetInfo true "0.0.1" "00" "DTP.MC.set0" "deployment_info/host"}} #要替换的部分
```

### 1.6.3 使用内置函数填充配置模板

本节内容主要说明如何构造函数中的service参数。

#### 1.6.3.1 获取非部署信息

按照servicelist.json文件中的层级结构，将各个键值以"."相连组合成路径即可。

示例：假设有服务清单如下：

```json
{
  "replicator_number": "3",
  "deployment_info": [
    {
      "hostname": "hostname1",
      "MUDP_BIND_IP": "{biznet.ip}"
    },
    {
      "hostname": "hostname2",
      "MUDP_BIND_IP": "{biznet.ip}"
    },
    {
      "hostname": "hostname3",
      "MUDP_BIND_IP": "{biznet.ip}"
    }
  ],
  "MUDP_IP": "224.1.0.4",
  "MUDP_NORMAL_PORT": "9999",
  "MUDP_SUPPLEMNET_PORT": "0",
  "MUDP_NOTIFY_PORT": "0",
  "mtp":{
      "kafka_topic":"mtp_b"
    },
  "kafka_broker": [
    "179.7.89.3:29092",
    "179.7.89.7:29092",
    "179.7.89.11:29092",
    "179.7.219.4:29092",
    "179.7.219.6:29092"
  ]
}
```

合法的service参数："kafka_broker"、"mtp.kafka_topic"
非法的service参数："kafka_broker.2"

#### 1.6.3.2 获取部署信息

按照servicelist.json文件中的层级结构，将各个键值以"."相连组合成路径即可。配置中心将自动确认索引，禁止在路径中手动添加。

示例：servicelist.json文件如2.2.1节中所示
合法的service参数："replicator_number"、"deployment_info.hostname"
非法的service参数："deployment_info.2.MUDP_BIND_IP"

## 1.7 操控流程文件

与用户无关，不做赘述

# 2.配置中心命令行工具使用方法

客户端命令行工具**仅在调试和紧急情况下使用**

## 2.1 编译

假设当前工作目录为$GOPATH，执行以下命令

```shell
cd $GOPATH/ConfigCenter/cmd/client
go build -a -o cfgtool
```

## 2.2 使用客户端命令行工具

### 2.2.1 create offline

```shell
create offline -v 0.0.1 -e 00 -c DTP.MC.set0 -g 0 -l 1 -t template_00.toml \
-i /Users/chenqr/Desktop/ConfigCenter/compressfiledemo/0.0.1.tar.gz \
-o /Users/chenqr/Desktop/res -u chqr 
```

### 2.2.2 create online

使用本地模板和服务端信息生成：

```shell
create online -v 0.0.1 -e 00 -c DTP.MC.set0 -g 0 -l 1 \
-i /Users/chenqr/Desktop/ConfigCenter/compressfiledemo/0.0.1/00/DTP.MC.set0/templates/template_00.toml \
-o /Users/chenqr/Desktop/res -u chqr
```

完全使用服务端信息生成：

```shell
create online -v 0.0.1 -e 00 -c DTP.MC.set0 -g 0 -l 1 \
-t template_00 \
-o /Users/chenqr/Desktop/res -u chqr
```

### 2.2.3 find

使用CtlFind函数实现单条查询

```shell
find -u chqr -o /Users/chenqr/Desktop/res \
-p "{{CtlFind \"services\" \"0.0.1\" \"00\" \"DTP.MC.set0\" \"deployment_info.2.directory\"}}" 
```

### 2.2.4 get

用于获取各类文件，输入目标文件对应的target关键字即可

```shell
get -u chqr -v 0.0.1 -e 00 -c DTP.MC.set0 -t templates -o /Users/chenqr/Desktop/res
```

### 2.2.5 delete

用于删除user名下缓存的配置文件

```shell
delete -u chqr
```

### 2.2.6 put

用于上传配置文件压缩包

```shell
put -u chqr \
-i /Users/chenqr/Desktop/ConfigCenter/compressfiledemo/0.0.1.tar.gz
```

### 2.2.7 post

用于提交版本

使用自动生成的版本号：

```shell
post -u chqr
```

使用指定的版本号：

```shell
post -u chqr -v 1.1.3
```

指定的版本号必须满足标准的三段式语义版本号，否则将返回错误
正例："0.1.0"、"2.10086.10"
反例："0.01.0"、"002.s.#"
