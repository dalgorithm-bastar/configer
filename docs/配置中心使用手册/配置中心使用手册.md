- [1.配置文件组织和构建规则](#1配置文件组织和构建规则)
  - [1.1 配置版本更新时的交互流程/配置文件生成过程](#11-配置版本更新时的交互流程配置文件生成过程)
    - [1.1.1 交互流程](#111-交互流程)
    - [1.1.2 生成过程](#112-生成过程)
  - [1.2 配置文件主体定义](#12-配置文件主体定义)
  - [1.3 总则](#13-总则)
  - [1.4 公共信息文件](#14-公共信息文件)
  - [1.5 服务清单文件](#15-服务清单文件)
  - [1.6 模板文件](#16-模板文件)
    - [1.6.1 go template基本语法](#161-go-template基本语法)
    - [1.6.2 内置函数](#162-内置函数)
      - [1.6.2.1 GetInfo](#1621-getinfo)
      - [1.6.2.2 UnsafeGetInfo](#1622-unsafegetinfo)
      - [1.6.2.3 GetNodeIdInfo](#1623-getnodeidinfo)
      - [1.6.2.4 ParseFloat](#1624-parsefloat)
      - [1.6.2.5 FmtFloat](#1625-fmtfloat)
      - [1.6.2.6 Itoa](#1626-itoa)
      - [1.6.2.7 Atoi](#1627-atoi)
      - [1.6.2.8 Add](#1628-add)
      - [1.6.2.9 Mine](#1629-mine)
    - [1.6.3 使用内置函数填充配置模板](#163-使用内置函数填充配置模板)
      - [1.6.3.1 获取非部署信息](#1631-获取非部署信息)
      - [1.6.3.2 获取部署信息](#1632-获取部署信息)
  - [1.7 操控流程文件](#17-操控流程文件)
- [2.项目部署](#2项目部署)
  - [2.1 运行环境](#21-运行环境)
    - [2.1.1 安装etcd](#211-安装etcd)
  - [2.2 设置配置中心本身的配置文件](#22-设置配置中心本身的配置文件)
    - [2.2.1 etcdClientv3.json](#221-etcdclientv3json)
    - [2.2.2 grpc.json](#222-grpcjson)
    - [2.2.3 log.json](#223-logjson)
  - [2.3 启动配置中心](#23-启动配置中心)
    - [2.3.1 启动etcd集群](#231-启动etcd集群)
      - [2.3.1.1 新建etcd用户并开启权限验证](#2311-新建etcd用户并开启权限验证)
      - [2.3.1.2 启动etcd集群](#2312-启动etcd集群)
    - [2.3.2 启动配置中心](#232-启动配置中心)
- [3.系统维护](#3系统维护)
  - [3.1 配置中心服务端](#31-配置中心服务端)
  - [3.2 etcd集群](#32-etcd集群)
    - [3.2.1 数据备份与恢复](#321-数据备份与恢复)
    - [3.2.2 删除节点](#322-删除节点)
    - [3.2.3 增加新节点](#323-增加新节点)
    - [3.2.4 节点异常处理与恢复](#324-节点异常处理与恢复)
  - [3.3 日志管理](#33-日志管理)
- [4.配置中心命令行工具使用方法](#4配置中心命令行工具使用方法)
  - [4.1 编译](#41-编译)
  - [4.2 使用客户端命令行工具](#42-使用客户端命令行工具)
    - [4.2.1 create offline](#421-create-offline)
    - [4.2.2 create online](#422-create-online)
    - [4.2.3 find](#423-find)
    - [4.2.4 get](#424-get)
    - [4.2.5 delete](#425-delete)
    - [4.2.6 put](#426-put)
    - [4.2.7 post](#427-post)
    - [4.2.8 cluster](#428-cluster)

# 1.配置文件组织和构建规则

## 1.1 配置版本更新时的交互流程/配置文件生成过程

请在充分理解以下内容的情况下阅读后续章节。

### 1.1.1 交互流程

用户使用配置中心网页前端更新配置版本时，在正常情况下，总共需要两步：

- 在本地选定配置文件压缩包，点击”提交“按钮，上传至配置中心。此时配置文件被缓存到用户名下。
- 用户点击”版本更新“按钮，此时配置中心服务端将用户名下缓存的配置作为新的版本提交，并返回版本号。

### 1.1.2 生成过程

用户在使用配置中心之前，需要了解相应文件在过程中扮演的角色

配置中心使用**配置模板**，在**服务清单**中查找模板上要求替换的内容，在获取到内容后，根据一定的规则判断该内容是否需要映射到**公共信息文件**上的某一项。如果需要映射且映射成立，将公共信息文件上的内容填充到配置模板上，否则填充服务清单上查找到的内容。

填充完成后，返回填充好的配置文件

## 1.2 配置文件主体定义

在正常情况下，提交配置时，配置中心服务端接收网页前端提交的配置压缩包并进行处理。用户需要提前在本地构建配置文件压缩包。

配置文件压缩包内应该仅包含一个文件夹，该文件夹内包含本次核心交易系统配置版本升级所需的所有配置文件，这些文件具体可分为四类：

- 公共信息文件，命名固定为infrastructure.json，每个版本有且仅有一份
- 服务清单文件，命名固定为servicelist.json，每个集群有且仅有一份
- 配置模板文件，名称格式无要求
- 操控流程文件，该类型文件与用户无关，用于操控中心启动各个集群

一个用于示例的文件结构如下所示，后续章节将给出详细的构建规则：

```shell
0.0.1
├── config1
│   ├── DTP.MC.set0
│   │   ├── manipulations
│   │   │   └── manipulation.yaml
│   │   ├── servicelist.json
│   │   └── templates
│   │       ├── template1.toml
│   │       └── template2.toml
│   └── EzEI.set1
│       ├── manipulations
│       │   └── manipulation.yaml
│       ├── servicelist.json
│       └── templates
│           ├── template1.toml
│           └── template2.toml
├── config2
│   ├── DTP.MC.set0
│   │   ├── manipulations
│   │   │   └── manipulation.yaml
│   │   ├── servicelist.json
│   │   └── templates
│   │       ├── template_88.toml
│   │       └── template_test.toml
│   └── EzEI.set1
│       ├── manipulations
│       │   └── manipulation.yaml
│       ├── servicelist.json
│       └── templates
│           ├── template_88.toml
│           └── template_test.toml
└── infrastructure.json
```

## 1.3 总则

文件组织规则和总体命名规则有如下几条：

- **建议**：文件夹根目录设置为期望的版本号。注意，该版本号并不会在缓存配置时被记录，用户如有需求，可在版本更新步时附带版本号。
&nbsp;
- **强制**：根目录有且只有一个，多于一个根目录将被视为错误。
&nbsp;
- **强制**：文件夹结构应当按照 根目录/环境号/集群名称 来进行组织，在这个基础上添加内容。在路径中间不得插入其他值。
  正例：0.0.1/00/DTP.MC.set0、0.0.1/88/EzEI.set1
  反例：0.0.1/envs/00/DTP.MC.set0
&nbsp;
- **强制**：templates被视为关键字，只允许出现在集群文件夹下，且必须以文件夹名称存在，否则将返回错误。注意，templates1、test_templates等命名是允许的。
  正例：0.0.1/00/DTP.MC.set0/templates/template_test
  反例：templates/00/DTP.MC.set0/templates/template_test
&nbsp;
对服务清单文件和公共信息文件的内容存在以下约束：

- **强制**：某一项的值不能为空，否则将报错。
  正例：TOPIC_TYPE = "1"  
  反例：TOPIC_TYPE = ""
&nbsp;
- **强制**："."是配置中心进行服务名称匹配时的分隔符，因此键值中不允许含有"."。
  正例：MUDP_IP = "10.1.1.2"  
  反例：MUDP.IP = "10.1.1.2"
&nbsp;
- **强制**：压缩包的格式应为tar.gz。
&nbsp;
- **强制**：在版本更新时，若指定版本号，必须满足标准的三段式语义版本号，否则将返回错误
正例："0.1.0"、"2.10086.10"
反例："0.01.0"、"002.s.#"

## 1.4 公共信息文件

- **建议**：公共信息文件中应当存放最为基础的信息，如物理机信息，此外，这些信息是对所有节点可见的，如果某项信息对可见性敏感，则不应将其放于此处。
&nbsp;
- **强制**：公共信息文件在单个版本的文件夹中唯一存在。
&nbsp;
- **强制**：文件路径必须为 根目录/，文件名必须为infrastructure.json。
&nbsp;
- **强制**：文件中不允许出现自定义结构体组成的数组，但可以使用字符串类型的数组作为值。
&nbsp;
- **强制**：文件中与某个主机名称相关的全部信息，应当全部放在以该主机名命名的结构体内。
正例：示例中hostname1、hostname2为主机名称，外层的normal为自定义前置属性，可多层嵌套也可删除。

```json
{
  "normal": {
    "hostname1": {
      "oplan": {
        "ip": "10.0.1.1"
      },
      "biznet": {
        "ip": "192.168.0.1"
      }
    },
    "hostname2": {
      "oplan": {
        "ip": "10.0.1.2"
      },
      "biznet": {
        "ip": "192.168.0.2"
      }
    }
  }
}
```

## 1.5 服务清单文件

- **建议**：服务清单文件中存放某一集群的部署信息和对外发布的服务信息，其他信息不应放置在此处。
&nbsp;
- **强制**：服务清单文件在某一集群所属的文件夹下有且仅有一份。
&nbsp;
- **强制**：服务清单文件的路径应为 根目录/环境号/集群名称/，文件名必须为servicelist.json。
&nbsp;
- **建议**：服务清单文件中，**除部署信息外，不建议使用自定义对象组成的数组**，若使用，则在一份模板的某个替换项中只能固定取到其中一个值。但是，使用字符串类型的数组作为值是允许的。
&nbsp;
- **强制**：部署信息中必须包含集群实例数目，以键值"replicator_number"放置在json文件根目录下。此外，应在根目录下以键值"deployment_info"建立集合，存放部署信息
&nbsp;
- **强制**：集群中每个实例的部署信息**按序对应**匿名数组中的一个结构体
&nbsp;
- **强制**：部署信息必须以匿名数组的形式提供，以便配置中心快速发现信息缺漏错误。取该数组的第几个值由接口中的localId参数决定，一般情况下由操控中心确定，无需用户手动干预。
&nbsp;
- **强制**：匿名数组中的每个元素应当包含一个键值为"hostname"的项，其值为该元素对应的物理主机名称。元素中的其他项，若需要进行映射，必须在值的首尾添加花括号{}，**配置中心将查找公共信息文件中，主机名为hostname值的主机，取该主机名下对应的该项信息进行填充**

一份符合规范的服务清单文件示例如下：

```json
{
  "replicator_number": "3",
  "deployment_info": [
    {
      "hostname": "hostname1",
      "MUDP_BIND_IP": "{biznet.ip}"  //将获取infrastructure.json中的hostname1.biznet.ip
    },
    {
      "hostname": "hostname2",
      "MUDP_BIND_IP": "{biznet.ip}"
    },
    {
      "hostname": "hostname3",
      "MUDP_BIND_IP": "{biznet.ip}"
    }
  ],
  "MUDP_IP": "224.1.0.4",
  "MUDP_NORMAL_PORT": "9999",
  "MUDP_SUPPLEMNET_PORT": "0",
  "MUDP_NOTIFY_PORT": "0",
  "kafka_broker": [
    "179.7.89.3:29092",
    "179.7.89.7:29092",
    "179.7.89.11:29092",
    "179.7.219.4:29092",
    "179.7.219.6:29092"
  ]
}
```

## 1.6 模板文件

模板文件没有格式要求，配置中心也不对其中内容进行解析。

- **强制**：模板文件的路径应为 根目录/环境号/集群名称/templates/，该文件夹下不允许出现子文件夹。模板文件名和文件数量无要求

### 1.6.1 go template基本语法

go template是golang的标准库之一，用于按照一定的规则替换文本中的某些部分。要替换的部分使用双重花括号括起来，其他部分会在进行替换后原封不动地保留。
  示例：

```toml
[rmb_publisher]
TOPIC_TYPE = "1"
HOST = {{GetInfo true "DTP.MC.set0" "deployment_info/host"}} #要替换的部分
```

- **强制**：注释在go template中无效，在构建配置模板时，应直接删除无用项
反例：

```toml
[rmb_publisher]
TOPIC_TYPE = "1"
# HOST = {{GetInfo true "DTP.MC.set0" "deployment_info/host"}} #要替换的部分
# go template仍然会识别该部分内容并加以处理，往往产生预料之外的错误。此类注释应当直接删除！
```

### 1.6.2 内置函数

内置函数是配置中心提供给用户的一组函数，用户可以在配置模板上使用内置函数获取服务清单上的特定信息

#### 1.6.2.1 GetInfo

用户需要替换时，应当在绝大多数情况下使用该函数

```go
//函数原型
func(defaultIndex bool, clusterObject, service string) (string, error){}

//defaultIndex
//表示是否使用localId作为索引，
//在获取带有自定义数组类型的部署信息时，应设为true，其他场景下应设为false

//clusterObject
//表示目标集群，即要在哪个集群下的服务清单里检索

//service
//服务信息名称，将在下一节中已经进行详细说明
```

用法示例：

```toml
[rmb_publisher]
TOPIC_TYPE = "1"
HOST = {{GetInfo true "DTP.MC.set0" "deployment_info.host"}} #要替换的部分
```

#### 1.6.2.2 UnsafeGetInfo

该函数提供跨版本和环境的检索功能，是不安全的，一般情况下不推荐使用

```go
//函数原型
func(defaultIndex bool, anyVersion, anyEnv, clusterObject, service string) (string, error) {}

//anyVersion
//目标版本号，即要在哪个版本下查询

//anyEnv
//目标环境，即要在哪个环境下查询

//其他参数与GetInfo一致
```

用法示例：

```toml
[rmb_publisher]
TOPIC_TYPE = "1"
HOST = {{UnsafeGetInfo true "0.0.1" "00" "DTP.MC.set0" "deployment_info/host"}} #要替换的部分
```

#### 1.6.2.3 GetNodeIdInfo

该函数可根据输入的节点号取相应的部署信息，可与循环搭配使用

```go
//函数原型
func(NodeId, clusterObject, service string) (string, error){}

//NodeId
//目标节点号，取决于该集群部署信息中数组索引

//其他参数与GetInfo一致
```

#### 1.6.2.4 ParseFloat

该函数可实现float64到string的转换

```go
//函数原型
func ParseFloat(s string) (float64, error){}

//s
//输入字符串
```

#### 1.6.2.5 FmtFloat

该函数可实现string到float64的转换

```go
//函数原型
func FmtFloat(i float64) string{}

//i
//输入浮点数
```

#### 1.6.2.6 Itoa

该函数可实现int到string的转换

```go
//函数原型
func Itoa(i int) string{}

//i
//输入整型数
```

#### 1.6.2.7 Atoi

该函数可实现string到int的转换

```go
//函数原型
func Atoi(s string) (int, error){}

//s
//输入字符串
```

#### 1.6.2.8 Add

该函数可实现float64输入加1

```go
//函数原型
func Add(i float64) float64{}

//i
//输入浮点数
```

#### 1.6.2.9 Mine

该函数可实现float64输入减1

```go
//函数原型
func Mine(i float64) float64{}

//i
//输入浮点数
```

### 1.6.3 使用内置函数填充配置模板

本节内容主要说明如何构造函数中的service参数。

#### 1.6.3.1 获取非部署信息

按照servicelist.json文件中的层级结构，将各个键值以"."相连组合成路径即可。

示例：假设有服务清单如下：

```json
{
  "replicator_number": "3",
  "deployment_info": [
    {
      "hostname": "hostname1",
      "MUDP_BIND_IP": "{biznet.ip}"
    },
    {
      "hostname": "hostname2",
      "MUDP_BIND_IP": "{biznet.ip}"
    },
    {
      "hostname": "hostname3",
      "MUDP_BIND_IP": "{biznet.ip}"
    }
  ],
  "MUDP_IP": "224.1.0.4",
  "MUDP_NORMAL_PORT": "9999",
  "MUDP_SUPPLEMNET_PORT": "0",
  "MUDP_NOTIFY_PORT": "0",
  "mtp":{
      "kafka_topic":"mtp_b"
    },
  "kafka_broker": [
    "179.7.89.3:29092",
    "179.7.89.7:29092",
    "179.7.89.11:29092",
    "179.7.219.4:29092",
    "179.7.219.6:29092"
  ]
}
```

合法的service参数："kafka_broker"、"mtp.kafka_topic"
非法的service参数："kafka_broker.2"

#### 1.6.3.2 获取部署信息

按照servicelist.json文件中的层级结构，将各个键值以"."相连组合成路径即可。配置中心将自动确认索引，禁止在路径中手动添加。

示例：servicelist.json文件如2.2.1节中所示
合法的service参数："replicator_number"、"deployment_info.hostname"
非法的service参数："deployment_info.2.MUDP_BIND_IP"

## 1.7 操控流程文件

该类型文件与用户无关，故不作描述

# 2.项目部署

## 2.1 运行环境

### 2.1.1 安装etcd

在需要**存储配置数据**的实例上，在安装完golang之后，还需要安装etcd，版本不低于3.3.25

安装包下载地址：https://github.com/etcd-io/etcd/releases/download/v3.5.1/etcd-v3.5.1-darwin-amd64.zip

在下载目录下解压：

```shell
tar -zxvf etcd-v3.5.1-darwin-amd64.zip
```

假设用户目录为$HOME，在该目录下执行以下命令：

```shell
mkdir go
cd go
mkdir pkg bin src
```

打开用户的系统配置文件

```shell
vim $HOME/.bashrc
```

插入并保存：

```shell
export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin
```

刷新文件：

```shell
source $HOME/.bashrc
```

进入解压后的同名文件夹：

```shell
cd etcd-v3.5.1-darwin-amd64
```

为了方便启动，执行以下命令：

```shell
cp etcd etcdctl etcdutl $GOPATH/bin
```

设置环境变量：

```shell
vim ~/.bashrc
```

在最后添加：

```shell
export ETCDCTL_API=3
```

刷新文件：

```shell
source ~/.bashrc
```

## 2.2 设置配置中心本身的配置文件

配置中心本身的配置文件放置于项目文件夹下的config/文件夹中，其结构如下：

```shell
config
├── etcdClientv3.json
├── grpc.json
└── log.json
```

其中etcdClientv3.json用于保存与etcd通信的相关信息，grpc.json用于设置服务端监听地址和端口，以及提交版本时加锁的时间，log.json可用于设置日志记录路径和等级等相关信息

### 2.2.1 etcdClientv3.json

一个示例的配置如下：

```json
{
  "endpoints": [
    "127.0.0.1:2379"
  ],
  "username": "root",
  "password": "sseTest2021",
  "operationtimeout": 3
}
```

- endpoints：应该包含etcd集群的所有监听地址和端口，在配置前应确定etcd集群部署情况
- username：etcd用户名，应设置为root
- password：etcd密码，应使用强度较高的密码
- operationtimeout：每次与etcd交互的超时时间，可根据网络情况酌情调整，单位为秒

### 2.2.2 grpc.json

一个示例的配置如下：

```json
{
  "endpoints":[
    "127.0.0.1:2333"
  ],
  "socket": "127.0.0.1:2333",
  "locktimeout": 30
}
```

- endpoints：grpc客户端可选的服务端套接字，在配置前应确定服务端部署情况
- socket：grpc服务端要监听的地址和端口
- locktimeout：提交版本时锁定etcd的时间，可根据网络情况和任务量大小酌情调整，单位为秒

### 2.2.3 log.json

一个示例的配置如下：

```json
{
  "logpath": "log/",
  "recordlevel": "debug",
  "encodingtype": "normal",
  "filename": "configcenter",
}
```

- logpath：日志文件保存的路径，默认为项目文件下的log/文件夹，此处的路径是相对于项目工作路径的路径
- recordlevel：日志打印的级别，可选debug或者info选项
- encodingtype：设定为normal时，输出命令行风格的信息，设置为json时，输出json风格信息
- filename：日志文件的文件名前缀，真正的文件名为filename+_当天日期.log，如示例中设置时，假设当天为2021年10月21日，则其文件名为configcenter_20211021.log

## 2.3 启动配置中心

### 2.3.1 启动etcd集群

请注意，etcd集群的节点数必须为奇数！

#### 2.3.1.1 新建etcd用户并开启权限验证

- 创建root用户
&nbsp;
  在安装好etcd的实例上打开终端，输入以下命令:
  
  ```shell
  etcd
  ```

  若有以下输出，代表启动成功：
  
  ```shell
  embed: serving insecure client requests on 127.0.0.1:2379, this is strongly discouraged!
  ```

&nbsp;

- 创建root用户
&nbsp;
  打开另一个终端，执行以下命令：

  ```shell
  etcdctl --user root user add root
  ```

  按提示要求设置密码并重复密码，若有以下输出，则表示创建成功：
  
  ```shell
  User root created
  ```

  该密码请妥善保管，且应当包含大写、小写和数字字符以及特殊字符，以提高安全性

&nbsp;

- 开启权限验证
&nbsp;
  执行以下命令：

  ```shell
  etcdctl auth enable
  ```

  若有以下输出，代表开启鉴权功能成功：
  
  ```shell
  Authentication Enabled
  ```

- 关闭集群以便后续操作
  在etcd集群启动的终端按ctrl+c结束进程

#### 2.3.1.2 启动etcd集群

假设要在以下三个实例上部署etcd集群：
|  节点名称   |     ip地址      |
| :-----: | :-----------: |
| rp0 |    10.0.1.10     |
|  rp1   | 10.0.1.11 |
| rp2 | 10.0.1.12 |

涉及etcd启动的关键参数：
|  参数名称   |     说明     |
| :------------: | :----------------------------------------------------: |
| --name |    etcd节点名字     |
|  --initial-cluster   | etcd启动的时候，通过这个配置找到其他ectd节点的地址列表，格式：'节点名字1=http://节点ip1:2380,节点名字1=http://节点ip1:2380,.....' |
| --initial-cluster-state | 初始化的时候，集群的状态 "new" 或者 "existing"两种状态，new代表新建的集群，existing表示加入已经存在的集群。 |
|--listen-client-urls|监听客户端请求的地址列表，格式：'http://localhost:2379', 多个用逗号分隔。|
|--advertise-client-urls|如果--listen-client-urls配置了，多个监听客户端请求的地址，这个参数可以给出，建议客户端使用什么地址访问etcd。|
|--listen-peer-urls|服务端节点之间通讯的监听地址，格式：'http://localhost:2380'|
|--initial-advertise-peer-urls|建议服务端之间通讯使用的地址列表。|

对于假设中给出的etcd集群中的三个实例，分别输入下列命令启动：
  
  ```shell
  # 节点一
  $ etcd --name rp0 --initial-advertise-peer-urls http://10.0.1.10:2380 \
  --listen-peer-urls http://10.0.1.10:2380 \
  --listen-client-urls http://10.0.1.10:2379,http://127.0.0.1:2379 \
  --advertise-client-urls http://10.0.1.10:2379 \
  --initial-cluster rp0=http://10.0.1.10:2380,rp1=http://10.0.1.11:2380,rp2=http://10.0.1.12:2380 \
  --initial-cluster-state new
  ```

  ```shell
  # 节点二
  $ etcd --name rp1 --initial-advertise-peer-urls http://10.0.1.11:2380 \
  --listen-peer-urls http://10.0.1.11:2380 \
  --listen-client-urls http://10.0.1.11:2379,http://127.0.0.1:2379 \
  --advertise-client-urls http://10.0.1.11:2379 \
  --initial-cluster rp0=http://10.0.1.10:2380,rp1=http://10.0.1.11:2380,rp2=http://10.0.1.12:2380 \
  --initial-cluster-state new
  ```

  ```shell
  # 节点三
  $ etcd --name rp2 --initial-advertise-peer-urls http://10.0.1.12:2380 \
  --listen-peer-urls http://10.0.1.12:2380 \
  --listen-client-urls http://10.0.1.12:2379,http://127.0.0.1:2379 \
  --advertise-client-urls http://10.0.1.12:2379 \
  --initial-cluster rp0=http://10.0.1.10:2380,rp1=http://10.0.1.11:2380,rp2=http://10.0.1.12:2380 \
  --initial-cluster-state new
  ```

启动完毕后，可在任一节点使用以下命令查看集群状态：

```shell
etcdctl --endpoints=http://10.0.1.12:2380,http://10.0.1.11:2380,http://10.0.1.10:2380 endpoint status --write-out=table
```

### 2.3.2 启动配置中心

在需要部署配置中心服务端的实例上，执行以下命令：

```shell
./configCenterServer
```

此时若命令行输出：

```shell
Server start
```

则该实例启动成功

# 3.系统维护

## 3.1 配置中心服务端

由于服务端只负责逻辑处理，因此只需要在服务端运行的终端结束进程，再进行相关操作即可。

使用离线项目包覆盖原项目方式进行升级时，应当先把原项目文件夹下的log文件夹复制并保存到指定文件夹中，以完成历史日志的记录和归档。

## 3.2 etcd集群

### 3.2.1 数据备份与恢复

在每次配置版本更新前，应当对etcd集群存储的数据进行备份

以2.3.1.2节中的集群为例，假设要将数据备份到/data/etcd_recover/文件夹下，备份的数据文件名称设置为etcd-snapshot.db，则备份该集群数据的步骤如下：

- 选定任一节点
  假定选择的节点是rp0
&nbsp;
- 输入以下命令备份：
  
  ```shell
  etcdctl --endpoints=10.0.1.10:2379 snapshot save /data/etcd_recover/etcd-snapshot.db
  ```

因为etcd集群的强一致性，在任一节点备份后即得到整个集群的备份数据
&nbsp;

需要恢复备份数据时，需要**停止etcd集群服务**，然后按照下列步骤执行：

- 将备份的数据拷贝到所有节点的指定文件夹下，这里假设该文件夹为$GOPATH/bin/recover
  &nbsp;
- 在每个节点执行恢复命令，以rp0为例，执行以下命令：
  
  ```shell
  etcdctl snapshot restore $GOPATH/bin/recover/etcd-snapshot.db
  --name rp0 \
  --data-dir $GOPATH/bin/rp0.etcd
  --initial-advertise-peer-urls http://10.0.1.10:2380 \
  --initial-cluster rp0=http://10.0.1.10:2380,rp1=http://10.0.1.11:2380,rp2=http://10.0.1.12:2380 
  ```
  
  其中，name应与原节点名称一致，data-dir为指定存放数据的目录，应在etcd运行目录下，文件名为节点名称，后缀为etcd。
  &nbsp;
- 在每个节点重新启动服务，按照2.3.1.2节中的内容启动即可

&nbsp;

### 3.2.2 删除节点

当节点出现异常或有特殊需求时，可以将其删除。

- 在任一可用节点上查看节点列表：
  
  ```shell
  etcdctl member list --write-out=table
  ```

- 在显示的信息中选择要删除的节点的ID值，执行以下命令删除：
  
  ```shell
  etcdctl member remove $ID #使用实际ID值替换
  ```

&nbsp;

### 3.2.3 增加新节点

**请注意，本节内容不适用于添加曾被删除过的节点！这类情况请参阅下一小节中的内容**

以2.3.1.2节中的集群为例，假设要向其中添加名称为rp3，套接字10.0.1.12:2380的节点

- 在任一现有节点中添加新节点：
  
  ```shell
  etcdctl member add rp3 http://10.0.1.12:2380
  ```

- 在新节点上启动服务：

  启动命令与上一节的内容基本一致，但因为集群已经存在，所以需要修改以下参数：
  
  ```shell
  --initial-cluster-state existing
  ```

&nbsp;

### 3.2.4 节点异常处理与恢复

当少数节点出现异常时，请按3.2.2节中的内容将节点临时删除，并做好数据备份

**删除的节点不得多于(总节点数N-1)/2**，若出现大面积宕机，请根据备份数据重启整个集群

在删除的节点数满足要求的情况下，问题解决后，可按下列指令将节点重新加入集群：

- 删除受损节点上的数据
  &nbsp;
  设要重新加入的节点名称为rp2，套接字10.0.1.11:2380

  ```shell
  cd $GOPATH/bin
  rm -r rp2.etcd
  ```

  &nbsp;
- 在任一现有节点上，向集群中添加节点：

  ```shell
  etcdctl member add rp3 --peer-urls=http://10.0.1.12:2380
  ```

  &nbsp;
- 启动重新加入的节点，执行3.2.3节中的启动命令即可

## 3.3 日志管理

日志文件按日期划分，但是若当天没有记录日志，则不会生成当日的日志文件。

日志文件均保存在项目文件夹下的log文件夹中。为防止文件堆积，应当**每个月**将日志文件剪切到专门存放运行日志的其他特定文件夹中。

# 4.配置中心命令行工具使用方法

客户端命令行工具**仅在调试和紧急情况下使用**，golang安装等基础步骤见第二章

## 4.1 编译

## 4.2 使用客户端命令行工具

### 4.2.1 create offline

```shell
./proxctl create offline -v 0.0.1 -e 00 -c DTP.MC.set0 -g 0 -l 1 -t template_00.toml \
-i ../../ConfigCenter/compressfiledemo/0.0.1.tar.gz \
-o /Users/chenqr/Desktop/res -u chqr 
```

### 4.2.2 create online

使用本地模板和服务端信息生成：

```shell
./proxctl create online -v 0.0.1 -e 00 -c DTP.MC.set0 -g 0 -l 1 \
-i ../../ConfigCenter/compressfiledemo/0.0.1/00/DTP.MC.set0/templates/template_00.toml \
-o /Users/chenqr/Desktop/res -u chqr
```

完全使用服务端信息生成：

```shell
./proxctl create online -v 0.0.1 -e 00 -c DTP.MC.set0 -g 0 -l 1 \
-t template_00 \
-o /Users/chenqr/Desktop/res -u chqr
```

### 4.2.3 find

使用CtlFind函数实现单条查询

```shell
./proxctl find -u chqr -o /Users/chenqr/Desktop/res \
-p "{{CtlFind \"services\" \"0.0.1\" \"00\" \"DTP.MC.set0\" \"deployment_info.2.directory\"}}" 
```

### 4.2.4 get

用于获取各类文件，输入目标文件对应的target关键字即可

```shell
./proxctl get -u chqr -v 0.0.1 -e 00 -c DTP.MC.set0 -t templates -o /Users/chenqr/Desktop/res
```

### 4.2.5 delete

用于删除user名下缓存的配置文件

```shell
./proxctl delete -u chqr
```

### 4.2.6 put

用于上传配置文件压缩包

```shell
./pro'x'c't'l put -u chqr \
-i ../../ConfigCenter/compressfiledemo/0.0.1.tar.gz
```

### 4.2.7 post

用于提交版本

使用自动生成的版本号：

```shell
./proxctl post -u chqr
```

使用指定的版本号：

```shell
./proxctl post -u chqr -v 1.1.3
```

指定的版本号必须满足标准的三段式语义版本号，否则将返回错误
正例："0.1.0"、"2.10086.10"
反例："0.01.0"、"002.s.#"

### 4.2.8 cluster

```shell
Create all configfiles of specified config scheme

Usage:
  proxctl cluster [flags]

Flags:
  -c, --cluster string    assign a cluster name
  -e, --env string        assign an environment number(required)
  -h, --help              help for cluster
  -m, --mode string       input "remote" or "local" to choose creating from remote or local(required)
  -i, --pathin string     assign input path
  -o, --pathout string    assign output path(required)
  -t, --template string   assign template
  -v, --version string    assign a config version(required)

Global Flags:
  -u, --user string   current userName(required)

```
