<center><font size=7>TD107新核心交易系统架构总体设计文档（配置中心卷）</font></center>

[toc]

# 概述

配置中心对交易系统的配置数据实行集中化、版本化的管理，各个集群需要向配置中心提供自身的部署信息文件、服务声明文件和配置模板，再由配置中心解析、校验并生成最终可用的组播信息文件和配置文件。

在使用配置中心生成配置文件之前，用户需要上传一份基础设施信息文件。该文件记录诸如主机信息、网络信息等内容。配置中心将根据基础设施文件，自动扩展各集群的部署信息文件。

# 名词解释

|    名词    |    释义    |        特殊说明        |
| :--------: | :-------------------: | :----------------: |
| 配置数据 | 与配置相关的数据，包括配置模板、服务清单、工作流程文件、公共信息文件、配置文件中的一项或多项 |        |
| 配置模板 | 包含固定配置信息以及可替换信息的文件 |  |
| 配置模板组 | 以应用集群为单位的一组配置模板 ||
| 配置文件 | 使用模板生成后的可用的配置文件 |  文件数量根据语境确定  |
| 服务声明文件 | 以集群为单位，包含该集群下所有服务的名称和内容的单个文件 |  |
| 工作流程文件 | 以集群为单位，包含操控中心启动该集群的流程信息 ||
| 服务信息 | 服务声明文件上的信息 |  |
| 基础设施信息文件 | 基础设施信息，如主机、网络信息 | |
| 前端 | 指配置中心前端，包含网页版和命令行工具 |           |
| 用户名 | 前端进行操作的用户的名称 |    |
| 自动化系统 | 需要从配置中心拉取配置的自动运行的系统，如操控中心 | |

# 参考文档

# 设计约束与已知限制

由于当前交易系统使用的配置文件格式多样、结构各异，因此配置中心不对具体的配置进行key-value存储，即配置中心不解析各个集群的配置模板。但配置中心提供基于gotemplate的文本替换，用户可使用预设参数，将实际值填充到模板的自定义位置。

# 整体视图

## 外部视图

配置中心由前端(包含命令行与网页端)、服务端和存储端组成。其中网页端借助envoy实现http与grpc之间的代理转发。其结构图如下：

![alt](images/概设/交互方4.0.svg)

## 内部视图

### 逻辑视图

按照逻辑功能的不同，可将配置中心分为接口模块(package pb)、服务模块(package service),生成模块(package generate),辅助模块(package util),日志模块(package log)，定义模块(package define)和存储模块(package repository，package datasource)

#### 模块关系图

![alt](images/概设/包图.svg)

#### 接口模块pb

配置中心服务端使用grpc实现一组接口，完成对外交互的需求。接口包含GET、PUT、POST和DELETE，接口行为与语义一致。配置中心的所有接口使用统一的请求结构体CfgReq和返回结构体CfgResp。

服务端接口由管理模块的Manager类实现，类图如下：

![alt](images/概设/处理模块.svg)

#### 服务模块service

管理模块负责直接处理接口模块接收的外部请求，并实现处理逻辑。管理模块不负责功能的具体实现，如储存和读取、模板的生成等，这些功能通过调用其他模块的接口实现。在处理完成后，管理模块负责将处理结果和请求结果返回接口模块。

#### 生成模块generate

该模块实现配置文件的生成。其输入为精确到配置方案的配置文件包、基础设施信息文件、ip范围、端口范围、环境号。其处理流程可参阅7.1节生成流程图。

#### 日志模块log

该模块负责管理可供其他模块调用的结构化日志对象和格式化日志对象。其类图如下：

![alt](images/概设/日志模块.svg)

#### 辅助模块util

该模块负责实现一组工具函数，实现文件的压缩和解压、字符串操作等辅助功能。包内包含两个源文件fileUtil.go和stringUtil.go，分别实现针对文件和字符串的相关功能。该包内还包含一个streamfile.go文件，实现了一个虚拟文件类型，用于流式文件的压缩解压，无实际用途。

#### 存储模块

存储模块分为repository接口层和datasource实现层。接口名称为Storage，其中定义了数据操作接口，datasource中分别定义了针对etcd和本地压缩包的实现类EtcdType和CompressedFileType，整个模块的类图如下：

![alt](images/概设/存储模块.svg)

# 数据结构

## 配置数据层级划分

下图给出了配置中心数据的层级关系：

![alt](images/概设/信息层级v3.1.svg)

一个用于示例的配置文件数据包树状结构为：

```shell
.
├── 3.1.0
│   ├── scheme1
│   │   ├── DTP
│   │   │   ├── CS
│   │   │   │   ├── deployment
│   │   │   │   │   ├── set1
│   │   │   │   │   │   └── deployment.yaml
│   │   │   │   │   └── set2
│   │   │   │   │       └── deployment.yaml
│   │   │   │   ├── service
│   │   │   │   │   ├── engine1
│   │   │   │   │   │   └── service.yaml
│   │   │   │   │   └── service.yaml
│   │   │   │   └── template
│   │   │   │       ├── app_shl.toml
│   │   │   │       ├── nilfile.toml
│   │   │   │       └── so1
│   │   │   │           └── so1.toml
│   │   │   └── MC
│   │   │       ├── deployment
│   │   │       │   ├── set1
│   │   │       │   │   └── deployment.yaml
│   │   │       │   └── set2
│   │   │       │       └── deployment.yaml
│   │   │       ├── service
│   │   │       │   └── service.yaml
│   │   │       └── template
│   │   │           └── app_shl.toml
│   │   └── MTP
│   │       └── RC
│   │           ├── deployment
│   │           │   ├── set1
│   │           │   │   └── deployment.yaml
│   │           │   └── set2
│   │           │       └── deployment.yaml
│   │           ├── service
│   │           │   └── service.yaml
│   │           └── template
│   │               └── app_shl.toml
│   └── scheme2
└── infrastructure.yaml
```

## rpc接口数据模型

### CfgReq

所有rpc请求的请求结构体均使用CfgReq，其内部结构之间的关系已在1.2.1节中给出，下面给出各个字段的含义

#### CfgReq

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| UserName |    string     | 当前操作者的用户名 |
|  Target   | string[] |   指令字符串，用于区分要获取的目标的类型   |
| Action | string | 指令字符串，用于描述修改动作 |
| EnvNum | string | 环境号 |
| File | AnyFile | 用于存放要提交的文件 |
| Version | string | 目标版本号 |
| Scheme | string | 目标配置方案 |
| Type | string | 目标信息类型 |
| Platform | string | 目标平台 |
| NodeType | string | 目标节点类型 |
| Set | string | 目标集群 |
| ArgRange | ArgRange | 输入ip、port范围 |

#### AnyFile

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| FileName |    string     | 文件名 |
|  Content   | byte[] |   文件内容   |

#### Target字段和接口、功能实现的对照表

Target字段主要用于确定要获取的资源种类，其类型为字符串，具备良好的可扩展性。

下表列出了各个功能点中Target关键字应当如何设置：

|     实现功能    |      接口      |      Target    | 说明 |
| :------------: | :-----------: | :-------------: | :-------------: |
| 获取生成的所有配置文件 |      GET       | "config" |  |
| 获取基础设施信息文件 |      GET       | "infra" |  |
| 获取所有版本号 |      GET       | "version" |   |
| 获取原始数据 |      GET       | "raw" |   |
| 获取用户缓存的数据 | GET | "cache" |  |
|  缓存配置数据   |      PUT       |  "raw"  | 目标版本号放在Version字段 |
|  提交基础设施信息文件   |      COMMIT       |  "infra"  |  |
|  提交用户缓存的数据   |      COMMIT       |  "raw"  |  |

#### Action字段和接口、功能实现的对照表

Action字段主要用于限定更新范围，其类型为字符串。

下表列出了各个功能点中Action关键字应当如何设置：

|     实现功能    |      接口      |      Action     | 说明 |
| :------------: | :-----------: | :-------------: | :-------------: |
|  缓存配置数据   |      PUT       |  "ResetAtRoot"  |  在版本范围内全量更新，必须上传符合格式要求的配置数据包，必须配合其他请求参数  |
|  缓存配置数据   |      PUT       |  "ResetAtLeaf"  |  在其他参数限定的范围内全量更新  |
|  缓存配置数据   |      PUT       |  "AddAndReplaceAtLeaf"  |  在其他参数限定的范围内增量更新(允许文件重名，重名即覆盖原文件)  |
| 缓存配置数据 | PUT | "AddButNoReplaceAtLeaf" | 在其他参数限定的范围内增量更新(重名时不覆盖原文件) |

#### Type字段和接口、功能实现的对照表

Type字段用于指定树状结构中的一层，但具有特殊限制，其用法如下：

|     实现功能    |      接口      |      Type     | 说明 |
| :------------: | :-----------: | :-------------: | :-------------: |
|  提交配置数据   |      PUT       |  "deployment"  | 更新部署信息 |
|  提交配置数据   |      PUT       |  "service"  |  更新服务信息  |
|  提交配置数据   |      PUT       |  "template"  |  更新配置模板  |
| 获取原始数据 |      GET       | "deployment" | 获取部署信息 |
| 获取原始数据 |      GET       | "service" | 获取服务信息 |
| 获取原始数据 |      GET       | "template" | 获取配置模板 |

#### ArgRange字段

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| TopicIp | []string  | 用于生成组播地址的Ip范围 |
| TopicPort | []string |  用于生成组播地址的端口范围  |

### CfgResp

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| status | string | "ok"或执行过程中的错误日志 |
| VersionList | VersionInfo[] | 版本号数组 |
| File | AnyFile | 文件数据 |

其中Version类型结构如下：

|  变量   |     类型      |                 说明                 |
| :-----: | :-----------: | :--------------------------: |
| Name | string | 标准三段式版本号 |
| User | string | 提交该版本号的用户 |
| Time | timestamp | 提交时间的13位时间戳 |

### 修改动作缓存表ChangeList

按照时间顺序缓存用户的修改行为、记录每次行为需要修改的文件，在某些情况下也可以没有文件。在有文件的情况下，文件保存在etcd中。该表结构如下：

```json
{
  "changeList":[
    {
      "stepOrder":1,
      "action":"ResetAtLeaf",
      "level":"scheme1/template/DTP",
      "keysToFile":["Path1","Path2"]
    },
    {
      "stepOrder":2,
      "action":"AddAndReplaceAtLeaf",
      "level":"scheme1/template/DTP/MC",
      "keysToFile":["Path3","Path4"]
    }
  ]
}
```

Path的规则见存储结构。

## 存储结构

etcd中的键值对如下表所示，其中&前缀表示取该变量的实际值，[]后缀代表该变量的一系列值的集合组成的逗号分隔字符串： 

| key | value | 说明 |
|:-----------------:|:------------------:|:-------------:|
| VersionList | string[] | 代表所有版本的序列，该序列有序 |
| &Version/SchemeList | string[] |代表某版本下配置方案的序列 |
| infrastructure | byte[] | 基础设施信息文件 |
| &Version/&Scheme/&Platform/&NodeType/&Type/&Set/&FileName |byte[] |某个set下的某份文件 |
| &Version/&Scheme/&Platform/&NodeType/&Type/&FileName | byte[] | 某节点类型下的某份文件|
|&UserName/&StepOrder/&Scheme/&Platform/&NodeType/&Type/&Set/&FileName | byte[] | 用户缓存的某个set下的某份文件 |
|&UserName/&StepOrder/&Scheme/&Platform/&NodeType/&Type/&FileName | byte[] |用户缓存的某节点类型下的某份文件|
|&Version/Perm.yaml|byte[]|该版本下配置模板权限记录文件|

## 输入配置文件包中的数据模型规范

参阅MAL107新核心交易系统架构用户手册（配置中心卷）

# 技术设计

## 生成配置文件流程图

![alt](images/概设/整体流程图.svg)

## 对生成第三方文件的支持

配置中心可针对第三方要求的配置文件样式进行生成。生成原则是，第三方文件的生成与配置中心自有生成方案分离，即第三方文件使用配置文件包、基础设施信息文件以及配置中心自有文件生成结果进行生成，不得侵入配置中心自有生成流程。

## 生成配置文件相关函数说明

配置中心在generation包中实现与配置文件生成有关的函数。该包的结构如下：

```shell
generation
├── deployment.go
├── entrance.go
├── entrance_test.go
├── nodecfg.go
├── struct.go
├── thirdPart.go
├── topicInfo.go
└── topicInfo_test.go
```

其中entrance.go为入口，deployment.go负责部署信息生成，topicInfo.go负责组播信息生成，nodecfg.go负责节点配置文件生成，thirdPart.go负责第三方配置文件生成，struct.go负责存放需要用到的结构体定义，其余为单测文件。

- entrance.go

该文件包含生成过程的入口函数，在无大的调整的情况下，应保证入口函数的签名不发生大的变化，而调整包内部的生成逻辑，从而使整个项目的结构稳定。

```go
// Generate 入口函数，由标准输入生成标准输出
// 输入参数依次为基础设施文件，某个配置方案下的所有原始文件，
// 环境号，组播IP段，组播端口段，tcp端口段
// 输出参数依次为生成结果，可能的错误
func Generate(infrastructure []byte, rawData map[string][]byte, 
envNum string, topicIpRange, topicPortRange, tcpPortRange []string) 
(map[string][]byte, error) 
```

Generate函数负责维护生成流程。在该函数内，首先对参数进行必要的校验，然后将输入的原始文件包转换为有序状态，再依次进行部署信息、组播信息、配置文件的生成，然后整理组播信息总表和部署信息总表，最后添加第三方配置文件。这些功能都通过调用包内的其他功能模块来实现。

```go
// 将原始文件map转换成字母序的slice
func sortRawData(rawData map[string][]byte) []RawFile
```

```go
// FinishResMap 在生成结果的基础上完成剩余的整理工作，即向结果中插入组播信息总表和部署信息总表
// 输入依次为输出文件包，部署信息表，组播信息表，路径前缀
// 输出为可能的错误
func FinishResMap(resMap map[string][]byte, 
dplyStructList []ChartDeployMain, 
topicInfoList map[string]map[string]map[string]ExpTpcMain, 
prePath string) error 
```

FinishResMap在生成结果的基础上完成剩余的整理工作，即向结果中插入组播信息总表和部署信息总表。

- deployment.go

```go
// GenerateDeploymentInfo 负责生成部署信息文件
// 输入基础设施信息文件，原始文件切片
// 输出以set为单位的部署信息表的集合，以及可能的错误
GenerateDeploymentInfo(infrastructure []byte, rawSlice []RawFile) 
([]ChartDeployMain, error)
```

GenerateDeploymentInfo 负责生成部署信息文件。该函数通过用户声明的部署要求，在基础设施信息文件中查找相应主机信息，并将这些信息复制到部署信息中。

- topicInfo.go

```go
// GenerateTopicInfo 负责生成组播信息
// 输入依次为部署信息表，有序原始文件包，环境号，组播IP段，组播端口段，tcp端口段
// 输出为平台-节点类型-集群->组播信息表的map，主机名->tcp端口占用信息的map，以及可能的错误
func GenerateTopicInfo(dplyStructList []ChartDeployMain, 
rawSlice []RawFile, envNum string, topicIpRange, topicPortRange, tcpPortRange []string) 
(map[string]map[string]map[string]ExpTpcMain, 
map[string]hostTcpUnit, []int, error) 
```

GenerateTopicInfo 负责生成组播信息，返回一个键为平台-节点类型-集群，值为组播信息表的map和一个主机名->tcp端口占用信息的map。该函数维护了一系列生成组播信息时应遵循的规则。其处理流程是先合并一个节点类型内的所有服务信息声明，再计算可用的IP、端口段，然后依次为每个节点类型生成bizTopic、setTopic以及集群内组播通道信息。

- nodeCfg.go

```go
// FillTemplates 负责填充配置模板，为每个节点生成一套配置文件
// 输入依次为部署信息表，有序原始文件，主机tcp端口信息map，tcp可用端口段，环境号，返回结果包
// 输出为返回结果根目录前缀，可能的错误
func FillTemplates(dplyStructList []ChartDeployMain, rawFile []RawFile, 
hostTcpPortMap map[string]hostTcpUnit, tcpRangeSli []int, envNum string, 
resMap map[string][]byte) 
(string, error)
```

FillTemplates 负责填充配置模板，为每个节点生成一套配置文件。该函数维护了所有模板填充的逻辑，可替换的内容可参考配置中心需求文档。

- thirdPart.go

该文件用于存放生成第三方配置文件的函数。目前只包含华锐的文件。第三方文件原则上应由配置中心生成结果和输入原始文件生成，其生成逻辑不应与配置中心自身生成逻辑杂糅。

```go
// huaRuiMain 用于生成华锐所需的配置文件
func huaRuiMain(infrastructure []byte, deployment []ChartDeployMain, 
topicList []byte) (map[string][]byte, error)
```

# 接口设计

为方便描述，本节中使用json结构体表示请求结构体进行演示。

## GET

GET接口可用于从服务端获取信息，包括原始数据（含配置模板、服务信息、部署信息、基础设施信息）和生成后的配置数据包。

### 获取生成后的配置文件

配置文件由配置中心动态生成，因此每次获取配置都是获取生成后的全量的配置文件。返回的文件包含生成的部署信息、生成的配置文件、生成的topicInfo总表。

以下为请求体示例：

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"config",
    "EnvNum":"00",
    "Version":"1.0.0",
    "Scheme":"scheme1",
    "ArgRange":{
      "TopicIp":["10.112.3.5","10.112.5.5"],
      "TopicPort":["1024","2376"],
      "TcpPort":["1024","60000"]
    }
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "VersionList":[],  //返回文件对象时此项为空
  "AnyFile": {
    "FileName":"name1", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

返回结构体中FileData的结构为：

```json
.
└── 3.1.0_scheme1
    ├── huarui_files
    │   ├── host.cfg
    │   ├── node.cfg
    │   └── route.cfg
    └── origin_res
        ├── DTP
        │   ├── CS
        │   │   ├── set1
        │   │   │   ├── deployment.yaml
        │   │   │   ├── host1_1
        │   │   │   │   ├── app_shl.toml
        │   │   │   │   ├── nilfile.toml
        │   │   │   │   └── so1
        │   │   │   │       └── so1.toml
        │   │   │   └── topicInfo.json
        │   │   └── set2
        │   │       ├── deployment.yaml
        │   │       ├── host2_2
        │   │       │   ├── app_shl.toml
        │   │       │   ├── nilfile.toml
        │   │       │   └── so1
        │   │       │       └── so1.toml
        │   │       └── topicInfo.json
        │   └── MC
        │       ├── set1
        │       │   ├── deployment.yaml
        │       │   ├── host1_3
        │       │   │   └── app_shl.toml
        │       │   ├── host2_4
        │       │   │   └── app_shl.toml
        │       │   └── topicInfo.json
        │       └── set2
        │           ├── deployment.yaml
        │           ├── host3_5
        │           │   └── app_shl.toml
        │           ├── host4_6
        │           │   └── app_shl.toml
        │           └── topicInfo.json
        ├── MTP
        │   └── RC
        │       ├── set1
        │       │   ├── deployment.yaml
        │       │   ├── host1_7
        │       │   │   └── app_shl.toml
        │       │   ├── host2_8
        │       │   │   └── app_shl.toml
        │       │   └── topicInfo.json
        │       └── set2
        │           ├── deployment.yaml
        │           ├── host3_9
        │           │   └── app_shl.toml
        │           ├── host4_10
        │           │   └── app_shl.toml
        │           └── topicInfo.json
        ├── deployList.json
        └── topicList.json
```

### 获取节点原始数据

以下请求体表示请求获取版本号1.0.0，配置方案scheme1，平台DTP，节点类型RC，类型template的所有配置文件模板。

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"raw",
    "Version":"1.0.0",
    "Scheme":"scheme1",
    "Platform":"DTP",
    "NodeType":"RC",
    "Type":"template"
  }
}
```

假设返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "VersionList":[],  //返回文件时此项为空
  "AnyFile": {
    "FileName":"DTP.RC.templates.tar.gz", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

要获取部署信息文件和服务信息文件，只需修改Type字段为相应的关键字即可。

返回结构体中FileData的结构为：

```json
template
├── app_shl.toml
├── biz_engine
│   ├── matcher_so
│   │   └── matcher_config.toml
│   └── riskcontrol_so
│       └── risk_control_config.toml
└── component
    ├── data_engine.toml
    ├── event_framework.toml
    └── logger.toml
```

### 获取基础设施信息文件

使用Target字段指明要导出的是"infra"。示例如下：

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"infra"
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "VersionList":[],  //返回文件时此项为空
  "AnyFile": {
    "FileName":"infrastructure.yaml", //文件名
    "FileData": //文件内容字节流数据
  }
}
```

### 获取所有版本号

使用Target字段指明要导出的是"version"。例如:

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"version",
  }
}
```

假设当前共有两个版本，v0.0.1和v0.0.2，则返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "VersionList":[
    {
      "name":"0.0.1",
      "user":"chfgu",
      "time":"xxxxxx"
    },
    {
      "name":"0.0.2",
      "user":"xwang3",
      "time":"xxxxxx"
    }
  ],
  //返回版本数据时该项为空
  "AnyFile": {
    "FileName":"", 
    "FileData":
  }
}
```

## PUT

PUT接口用于缓存用户单次提交的修改，用户在请求体中用参数限定修改动作的范围，并在上传的配置数据包中提交相应的文件。当前仅支持全量缓存。用户someBody想要缓存的配置数据包位于本地config文件夹下，则构建的请求体如下：

```json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"raw",
    "AnyFile":{
      "FileName":"config.tar.gz",
      "Content":"content"
    }
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok"
}
```

下面分别就针对部署信息和针对其他配置数据的缓存进行演示，计划在后续版本中添加。

### 缓存对部署信息的修改

用户someBody想要重置（reset）DTP.RC.set1层级的部署信息，则应构建请求体如下：

```json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"raw",
    "Action":"ResetAtLeaf",
    "Scheme":"scheme1", //指定配置方案，默认更新在最新版本的配置数据上
    "Platform":"DTP",
    "NodeType":"RC",
    "Type":"template",
    "Set":"set1",
    "AnyFile":{
      "FileName":"deployment.yaml",
      "Content":"content"
    }
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok"
}
```

此处示例为更新单个set，实际情况下可以在节点类型或更高层级进行更新。若在更高层级更新，需构建与配置中心数据包结构一致的上传文件数据包。

### 缓存对配置数据的修改

用户someBody想要更新（AddAndReplaceAtLeaf）DTP.RC层级的**某些**配置模板，则应构建请求体如下：

```json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"raw",
    "Action":"ResetAtLeaf",
    "Scheme":"scheme1", //指定配置方案，默认更新在最新版本的配置数据上
    "Platform":"DTP",
    "NodeType":"RC",
    "Type":"template",
    "AnyFile":{
      "FileName":"app_shl.toml",
      "Content":"content"
    }
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok"
}
```

在用户提交后，配置中心的配置数据包中RC.template下的app_shl.json文件将被替换。

## COMMIT

### 提交缓存的配置数据

COMMIT接口用于提交版本，请求体内的Target关键字设为raw。例如，下列请求体表示请求配置中心提交用户someBody请求上传的配置。

``` json
{
  "CfgReq":{
    "UserName":"someBody",
    "Target":"raw"
  }
}
```

假设本次提交创建的版本号为0.0.3，则返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok",
  "VersionList":[
    {
      "Version":"0.0.3",
      "User":"someBody",
      "Time":"xxxxxxx"
    }
  ],
  "AnyFile": {
      "FileName":"", 
      "FileData":
  }
}
```

用户也可在version字段中指定本次提交的版本号。配置中心在检测到版本号不冲突后将以该版本号提交，否则返回一个错误提示

### 提交基础设施信息

COMMIT接口用于提交基础设施信息，请求体内的Target关键字设为infra。例如，下列请求体表示请求配置中心提交用户someBody请求上传的infrastructure.json。

``` json
{
  "CfgReq":{
  "UserName":"someBody",
  "Target":"infra",
  "File":{
      "FileName":"infrastructure.yaml",
      "Content":"content"
    }
  }
}
```

返回的结构体CfgResp为(假设请求成功)：

```json
{
  "Status":"ok"
}
```

## DELETE

delete接口负责删除用户目录下缓存的修改信息。构建请求体如下：

```json
{
  "CfgReq":{
    "UserName":"someBody"
  }
}
```

## GetLatestConfigByEnvNum

GetLatestConfigByEnvNum接口负责根据传入的环境号获取该环境号下的最新配置

接口原型：

```go
//获取某一环境号下最新生成的配置文件
//输入为环境号
//输出为配置文件压缩包，压缩格式为.tar.gz，或可能的错误
func GetLatestConfigByEnvNum(envNum string)(configFile AnyFile,error err){}

//AnyFile结构体，用于文件传输
type AnyFile struct {
    FileName             string
    FileData             []byte
}
```

构建请求体如下：

```json
{
  "envNum": "01"
}
```

返回结构体如下：

```json
{
  "AnyFile":{
    "FileName":"config.tar.gz",
    "FileData":data
  }
}
```

# 操控设计

参阅MAL107 新核心交易系统架构用户手册（配置中心卷）第三章 使用配置中心

# 监测设计

暂无

# 附录

## 直接引用的包列表

|包名称|用途|
|:------------:|:-------------:|
|github.com/agiledragon/gomonkey/v2|单测时用于函数打桩|
|github.com/coreos/etcd|运行时用于操作etcd接口|
|github.com/golang/mock|单测时用于模拟接口行为|
|github.com/golang/protobuf|运行时用于grpc编解码|
|github.com/lestrrat/go-file-rotatelogs|运行时用于日志文件切分|
|github.com/mholt/archiver|运行时用于流式文件的压缩和解压|
|github.com/spf13/cobra|运行时用于解析命令行命令|
|github.com/spf13/viper|运行时用于解析配置文件和校验输入项|
|go.uber.org/zap|运行时用于打印日志|
|golang.org/x/net|运行时用于grpc编解码|
|google.golang.org/grpc|运行时用于实现rpc服务|
|gopkg.in/yaml.v3|运行时用于yaml文件编解码|
|xchg.ai/sse/gracefully|运行时用于多个goroutine的优雅退出|
